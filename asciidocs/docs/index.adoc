= Security: Userverwaltung
Tobias J. Aichinger, Moritz V. Gruber, Lukas Sonnleitner
1.0, {docdate}
ifndef::sourcedir[:sourcedir: ../src/main/java]
ifndef::imagesdir[:imagesdir: images]
ifndef::backend[:backend: html5]
:icons: font
:sectnums:    // Nummerierung der √úberschriften / section numbering
:toc: left
:source-highlighter: rouge
:docinfo: shared

Standard Flow:

JWT:

* Wie es verschl√ºsselt worden
* Payload mit Daten drinnen
* Signature

Claim ist zB eine E-Mail
Scope ist eine collection von Claims

*Security* ist ein Begriff, welcher

== Authentifizierung und Autorisierung
Authentifizierung durch Eingabe von Username und Passwort ‚Üí *Wer bin ich?*

Durch Rollen ist man autorisiert, auf Ressourcen zuzugreifen ‚Üí *Was darf ich?*

== Rollen
image:roles.png[]

== Standards
=== OAuth 2.0
image:oauth2-logo.png[width=200]

[underline]#Bezeichnung#: O~pen~ Auth~orization~ 2.0

==== Definition
*OAuth 2.0* ist ein *Protokoll*, welches f√ºr die *Autorisierung* verantwortlich ist. Der Vorg√§nger *0Auth 1.0* wurde ausschlie√ülich f√ºr Webseiten entwickelt und wird nicht mehr h√§ufig verwendet.

Mehr Informationen link:https://auth0.com/de/intro-to-iam/what-is-oauth-2[hier^].

IMPORTANT: Die Authentifizierung von Benutzern wird bei OAuth 2.0 *nicht* abgedeckt.

image:oauth2-authorization-code-flow.png[]
TODO: Erkl√§rung

=== OIDC
image:oidc-logo.png[width=200]

[underline]#Bezeichnung#: O~pen~ID C~onnect~

==== Definition
*OIDC* ist ein *Protokoll*, welches auf 0Auth 2.0 aufbaut und eine zus√§tzliche Schicht f√ºr die *Authentifizierung* hinzuf√ºgt.

Mehr Informationen link:https://auth0.com/de/intro-to-iam/what-is-openid-connect-oidc[hier^].

image:oidc-authorization-code-flow.png[]
TODO: Erkl√§rung

=== SAML 2.0
image:saml-logo.png[width=200]

[underline]#Bezeichnung#: S~ecurity~ A~ssertion~ M~arkup~ L~anguage~ 2.0

==== Definition
*SAML 2.0* ist ein XML-basiertes Standardprotokoll f√ºr Authentifizierung und Autorisierung. Es wird h√§ufig verwendet, um Single Sign-On in Unternehmens- und Regierungsanwendungen zu erm√∂glichen. Das Protokoll erm√∂glicht es bestehenden Benutzern sich schnell und einfach in neuen Anwendungen zu authentifizieren.

Mehr Informationen link:https://auth0.com/de/intro-to-iam/what-is-saml[hier^].

=== JWT
image:jwt-logo.svg[width=200]

[underline]#Bezeichnung#: J~son~ W~eb~ T~oken~

==== Definition
*JSON Web Token* ist ein offener Standard, der eine kompakte M√∂glichkeit zur sicheren √úbertragung von Informationen zwischen Parteien als JSON-Objekt definiert. Diese Information wird digital *signiert* und sind somit vertrauensw√ºrdig.



==== Struktur
Ein JWT setzt sich aus 3 Teilen zusammen, welche jeweils durch einen `.` getrennt werden: `xxxxx.yyyyy.zzzzz`


===== Header: (`XXXXX`.yyyyy.zzzzz)

Besteht aus 2 Teilen:

.Beispiel
[source, json]
----
{
  "alg": "HS256", <.>
  "typ": "JWT" <.>
}
----
<.> Verwendeter Signieralgorithmus: link:https://stackoverflow.com/questions/39239051/rs256-vs-hs256-whats-the-difference[Unterschied zwischen *HS256* und *RS256*^]
<.> Typ des Tokens

Dieses JSON wird *Base64* verschl√ºsselt und macht somit den *ersten* Teil des JWTs aus.

===== Payload: (xxxxx.`YYYYY`.zzzzz)

Die Payload enth√§lt die Claims. *Claims* sind meistens Daten √ºber den User und zus√§tzliche Daten. Es gibt 3 Arten von Claims:

* *Registered* Claims: Vordefinierte Claims wie z. B. `exp` (expiration time) und noch link:https://datatracker.ietf.org/doc/html/rfc7519#section-4.1[mehr^]
* *Public* Claims: TODO
* *Private* Claims: Sind eigens *benutzerdefinierte* Claims, welche f√ºr den Informationsaustausch zweier Parteien fungieren.

.Beispiel
[source, json]
----
{
  "exp": "1734137921",
  "name": "John Doe",
  "admin": true
}
----

Dieses JSON wird *Base64* verschl√ºsselt und macht somit den *zweiten* Teil des JWTs aus.

===== Signature: (xxxxx.yyyyy.`ZZZZZ`)

Im dritten Part wird der `Header`, die `Payload` und ein `Secret` mit den im Header angegebenen Signieralgorithmus signiert.

.Beispiel f√ºr HS256
[source]
----
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)
----

Die Signatur kann sicherstellen, dass die Nachricht nicht von Dritten ge√§ndert wurde. Dies macht den *dritten* Teil des JWTs aus.

===== Zusammenfassung:

Das Ergebnis sind 3 Base64 Strings, welche durch einen `.` separiert werden.

Mehr Informationen link:https://jwt.io/introduction[hier^].

== Keycloak
=== Was ist Keycloak?
Keycloak ist eine *Open-Source*-Identity- und Access-Management-L√∂sung, die Funktionen wie Single Sign-On (SSO), Benutzerverwaltung und Social Login bietet.

IMPORTANT: *Single Sign-On* ist ein Authentifizierungsverfahren, bei dem Benutzer sich nur einmal anmelden und anschlie√üend auf mehrere Anwendungen oder Systeme zugreifen k√∂nnen, ohne sich erneut authentifizieren zu m√ºssen.

=== Alternativen

[%header, cols="1,1,1,1,1"]
|===
|
^.^|link:https://www.keycloak.org/[Keycloak^]
^.^|link:https://auth0.com/[Auth0^]
^.^|link:https://www.authelia.com/[Authelia^]
^.^|link:https://goauthentik.io/[authentik^]

^.^|*Open Source*
^.^|üü¢
^.^|üî¥
^.^|üü¢
^.^|üü¢

^.^|*Protocol Support:* OAuth 2.0 und OIDC
^.^|üü¢
^.^|üü¢
^.^|üü¢
^.^|üü¢

^.^|*Protocol Support:* SAML 2.0
^.^|üü¢
^.^|üü¢
^.^|üî¥
^.^|üü¢

^.^|*Language*
^.^|image:java-logo.png[width=40, height=40]
^.^|404
^.^|image:go-logo.png[width=40, height=40]
^.^|image:python-logo.png[width=40, height=40]
|===

=== Wichtigste Bestandteile in Keycloak

=== Custom Theme

== Keycloak mit dem quarkus-keycloak-admin-rest-client
F√ºr die Kommunikation zwischen der *Quarkus-Applikation* und *Keycloak* wird die link:https://quarkus.io/guides/security-keycloak-admin-client[quarkus-keycloak-admin-rest-client^] dependency verwendet. Der Rest-Client sendet Requests an die link:https://www.keycloak.org/docs-api/latest/rest-api/index.html[`Keycloak Admin REST API`^].

=== Projekterstellung
TODO: restlichen dependencies hinzuf√ºgen

.Projekterstellung mit Quarkus CLI
[source, shell]
----
quarkus create app at.htl:security-keycloak-admin-client \
    --extension='keycloak-admin-rest-client,rest-jackson' \
    --no-code
----

TODO: Version checken

.Projekterstellung mit Maven CLI
[source, shell]
----
mvn io.quarkus.platform:quarkus-maven-plugin:3.17.3:create \
    -DprojectGroupId=at.htl \
    -DprojectArtifactId=security-keycloak-admin-client \
    -Dextensions='keycloak-admin-rest-client,rest-jackson' \
    -DnoCode
----

.Dependencies aus pom.xml
[source, xml]
----
<!-- ... -->
<dependencies>
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-keycloak-admin-rest-client</artifactId>
    </dependency>
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-rest-jackson</artifactId>
    </dependency>
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-arc</artifactId>
    </dependency>
</dependencies>
<!-- ... -->
----

=== Keycloak Container starten

* `keycloak` Ordner auf der Ebene des Quarkus-Projekts erstellen

[source, shell]
----
mkdir keycloak
----

* Im `keycloak` Ordner eine Datei namens `docker-compose.yml` erstellen

[source, shell]
----
cd keycloak
touch docker-compose.yml
----

* Das `docker-compose.yml` mit folgendem Code bef√ºllen

[source, yaml]
----
services:
  keycloak: #<.>
    container_name: keycloak-demo #<.>
    image: quay.io/keycloak/keycloak:26.0.7 #<.>
    environment:
      - KEYCLOAK_ADMIN=admin #<.>
      - KEYCLOAK_ADMIN_PASSWORD=admin #<.>

      - KC_HOSTNAME_STRICT=false #<.>
      - KC_HTTP_ENABLED=true #<.>
      - KC_HOSTNAME=localhost #<.>
      - PROXY_ADDRESS_FORWARDING=true #<.>
      - KC_HEALTH_ENABLED=true #<.>
    command: ["start-dev"] #<.>
    ports:
      - "8000:8080" #<.>
----
.Erkl√§rung
[%collapsible]
====
<.> Der Name des Services
<.> Der Name des Containers
<.> Es wird die aktuellste Version `26.0.7` von Keycloak verwendet
<.> Umgebungsvariable f√ºr den Usernamen des Admins
<.> Umgebungsvariable f√ºr das Passwort des Admins
<.> TODO
<.> TODO
<.> TODO
<.> TODO
<.> TODO
<.> TODO
<.> Der *interne* Port auf der *rechten* Seite wird auf den *√§u√üeren* Port auf der *linken* Seite gemappt TODO
====

* Den Container mit folgendem Befehl starten

[source, shell]
----
docker compose up
----

* Nun kann auf `http://localhost:8000`, auf den laufenden Keycloak Container zugegriffen werden. In der Anmeldemaske kann man sich mithilfe der im `docker-compose.yml` angegebenen Username und Passwort als Admin anmelden.

.Anmeldemaske
[%collapsible]
====
image::keycloak-admin-login.png[]
====

.Admin-Konsole
[%collapsible]
====
image::keycloak-admin-console.png[]
====

=== Realm erstellen

IMPORTANT: TODO: Realm Beschreibung

Um einen *Realm* zu erstellen, muss man im linken oberen Eck auf das Dropdown und anschlie√üend auf den Button `Create realm` klicken.

.Realm erstellen Button
[%collapsible]
====
image::keycloak-create-realm-button.png[]
====

* Namen vergeben (z. B. my-realm)
* `Enabled` Option auf `On` lassen
* Auf den `Create` Button klicken

.Realm erstellen
[%collapsible]
====
image::keycloak-create-realm-window.png[]
====

=== Quarkus-Client erstellen

IMPORTANT: TODO: Client Beschreibung

Um einen *Client* zu erstellen, muss man im Clients Tab auf den `Create client` Button klicken.

.Client erstellen
[%collapsible]
====
image::keycloak-create-client-button.png[]
====

*General Settings*

* Als `Client ID` wird in diesem Beispiel der Name `quarkus-client` gew√§hlt
* Name und Description sind optional
* `Always display in UI` auf `On`, um Client dauerhaft im UI anzuzeigen

.Client erstellen - General Settings
[%collapsible]
====
image::keycloak-create-client-general-settings.png[]
====

*Capability config*

* `Client Authentication` auf `On` (TODO)
* `Authorization` auf `On` (TODO)
* `Authentication flow` (TODO)

.Client erstellen - Capability config
[%collapsible]
====
image::keycloak-create-client-capability-config.png[]
====

*Login settings*

TODO

* Standard flow
* [line-through]#Implicit flow#: deprecated

=== Probe
Nachdem nun ein *Realm* und ein *Client* in Keycloak existieren, k√∂nnen wir den *keycloak-admin-client* ausprobieren.

.application.properties
[source, properties]
----
# Quarkus keycloak-admin-client
quarkus.keycloak.admin-client.enabled=true <.>
quarkus.keycloak.admin-client.server-url=http://localhost:8000 <.>
quarkus.keycloak.admin-client.realm=my-realm <.>
quarkus.keycloak.admin-client.client-id=quarkus-client <.>
----
<.> true, wenn injection von Keycloak-Admin-Client unterst√ºtzt werden soll
<.> Die URL des Keycloak-Servers
<.> Der Name des Realms, worin sich der Client befindet
<.> Der Name des erstellten Clients

.Beispiels-Endpunkt
[source, java]
----
package at.htl.keycloakDemo.resources;

import jakarta.inject.Inject;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.Response;
import org.keycloak.admin.client.Keycloak;

@Path("/admin")
public class RolesResource {
    @Inject
    Keycloak keycloak;

    @GET
    @Path("/roles")
    public Response getRoles() {
        return Response.ok(
            keycloak
                .realm("my-realm")
                .roles()
                .list()
        ).build();
    }
}
----
TODO: Erkl√§rung

==== Response
[source, json]
----
{
  "details": "Error id bc6db0c5-e662-4e91-80e2-48e50026eb69-6, org.jboss.resteasy.reactive.ClientWebApplicationException: Received: 'Server response is: 401' when invoking REST Client method: 'org.keycloak.admin.client.token.TokenService#grantToken'"
}
----

Der Keycloak-Server gibt eine *401 - Unauthorized* Response zur√ºck. Um dies zu beheben, m√ºssen wir unsere *Quarkus-Applikation* mit dem Keycloak authentifizieren.

==== Authentifizierung
Es gibt 2 M√∂glichkeiten zur Authentifizierung mit dem *keycloak-admin-client*.

* password
* client-credentials

TODO: grant type erkl√§ren

===== Grant type: password
.application.properties
[source, properties]
----
# Quarkus keycloak-admin-client
quarkus.keycloak.admin-client.enabled=true
quarkus.keycloak.admin-client.server-url=http://localhost:8000
quarkus.keycloak.admin-client.realm=my-realm
quarkus.keycloak.admin-client.client-id=admin-cli <1>
quarkus.keycloak.admin-client.grant-type=password <2>
quarkus.keycloak.admin-client.username=alice <3>
quarkus.keycloak.admin-client.password=alice <3>
----
<.> F√ºr die `password` Variante muss die *client-id* auf `admin-cli` ge√§ndert werden. Dieser Admin-Client ist ein default client, auf welchem die *Client authentication* und *Authorization* ausgeschaltet sind. Allerdings brauchen wir diese bei dieser Variante nicht. TODO: √ºberpr√ºfen
<.> Setzt den *grant-type* auf `password`.
<.> Username und Passwort des erstellten Users.

.User erstellen
[%collapsible]
====
Im erstellten Realm auf `Users` -> `Add user` klicken.

WARNING: Obwohl nur *Username* ein Pflichtfeld ist, m√ºssen auch *Email*, *First name* und *Last name* ausgef√ºllt werden. Anderenfalls gibt Keycloak bei s√§mtlichen Requests einen *400 - Bad Request* zur√ºck.

image:keycloak-add-user.png[]
====

===== Grant type: client-credentials
.application.properties
[source, properties]
----
# Quarkus keycloak-admin-client
quarkus.keycloak.admin-client.enabled=true
quarkus.keycloak.admin-client.server-url=http://localhost:8000
quarkus.keycloak.admin-client.realm=my-realm
quarkus.keycloak.admin-client.client-id=quarkus-client
quarkus.keycloak.admin-client.grant-type=client-credentials <.>
quarkus.keycloak.admin-client.client-secret=<secret> <.>
----
<.> Legt fest, wie die Quarkus-Anwendung Zugangstokens von Keycloak erh√§lt, um administrative Aufgaben auszuf√ºhren. Hier wird der `client-credentials` type gemeinsam mit den *client-secret* benutzt.
<.> Der `client-secret` des erstellten Clients. Dieser ist unter folgendem Pfad zu finden: `Clients` -> `<client-name>` -> `Credentials` -> `Client Secret`

.Client secret
[%collapsible]
====
image:keycloak-client-secret.png[]
====

Jetzt probieren wir denselben Endpunkt nochmals aus.

==== Response
[source, json]
----
{
  "details": "Error id bc6db0c5-e662-4e91-80e2-48e50026eb69-5, org.jboss.resteasy.reactive.ClientWebApplicationException: Received: 'Server response is: 403' when invoking REST Client method: 'org.keycloak.admin.client.resource.RolesResource#list'"
}
----

Diesmal bekommen wir vom Keycloak-Server eine *403 - Forbidden* Response. Wir sind nun authentifiziert, allerdings ist der *quarkus-client* bzw. der User *alice* nicht autorisiert alle Rollen anzuzeigen.

==== Autorisierung
===== Grant type: password
Unter `Users` -> `<username>` -> `Role mapping` -> `Assign role` k√∂nnen dem User Rollen zugewiesen werden. Wir weisen dem User die Rolle `view-realm` zu, um *lesenden* Zugriff auf den *Realm* zu bekommen.

.User roles
[%collapsible]
====
image:keycloak-user-roles.png[]]
====

===== Grant type: client-credentials
Unter `Clients` -> `<client-name>` -> `Service accounts roles` -> `Assign role` k√∂nnen dem Client Rollen zugewiesen werden. Wir weisen dem Client die Rolle `view-realm` zu, um *lesenden* Zugriff auf den *Realm* zu bekommen.

.Client roles
[%collapsible]
====
image:keycloak-client-roles.png[]]
====

==== Response
[source, json]
----
[
  {
    "id": "1a6cc8e5-87ee-4871-a946-23f406bacea1",
    "name": "uma_authorization",
    "description": "${role_uma_authorization}",
    "scopeParamRequired": null,
    "composite": false,
    "composites": null,
    "clientRole": false,
    "containerId": "a22e79d4-1c88-4ce2-87a2-4757186910c1",
    "attributes": null
  },
  {
    "id": "6f822b0e-6db4-454d-a205-84f0bcd08aeb",
    "name": "offline_access",
    "description": "${role_offline-access}",
    "scopeParamRequired": null,
    "composite": false,
    "composites": null,
    "clientRole": false,
    "containerId": "a22e79d4-1c88-4ce2-87a2-4757186910c1",
    "attributes": null
  },
  {
    "id": "27fd8fbd-7bdf-4b5e-ad05-340a49c2c2f4",
    "name": "default-roles-my-realm",
    "description": "${role_default-roles}",
    "scopeParamRequired": null,
    "composite": true,
    "composites": null,
    "clientRole": false,
    "containerId": "a22e79d4-1c88-4ce2-87a2-4757186910c1",
    "attributes": null
  }
]
----

Jetzt werden die 3 default *Realm roles* als Response geliefert.

==== Zusammenfassung
TODO

== Reverse Proxies


=== Was ist ein Reverse Proxy?

Ein Reverse Proxy ist ein Server, der die Anfragen von Clients zu einem oder mehreren Servern weiterleitet. +
Ein Reverse Proxy ist stellvertetend f√ºr die Server. +
Ein Proxy ist stellvertretend f√ºr die Clients.

.Reverse Proxy
image:reverse-proxy.svg[]

.Proxy
image:proxy.svg[]

=== Warum braucht man einen Reverse Proxy?

* Rate Limiting
* Routing
* Authentication
* Request Validierung
* Loadbalancing
* Caching

=== Reverse Proxies im √úberblick

[%header, cols="1,1,1,1,1"]
|===
|
|link:https://nginx.org/en/[Nginx^]
|link:https://traefik.io/[Traefik^]
|link:https://caddyserver.com/[Caddy^]
|link:https://github.com/cloudflare/pingora[Pingora^]

|Benutzerfreundlichkeit
^.^|üü°
^.^|üü¢
^.^|üü¢
^.^|üî¥

|Configuration
|.conf
|.yaml +
.toml +
docker labels ... +
link:https://doc.traefik.io/traefik/providers/overview/#supported-providers[Alle Configurations Optionen]
|Caddyfile +
.json +
API
|Rust

|TLS/Https
|Manuell / Automatisiert mit Certbot
|Manuell / Automatisiert mit Certbot
|Automatisiert
|Manuell

|Kubernetes üòà
^.^|üü¢
^.^|üü¢
^.^|üü° link:https://github.com/caddyserver/ingress[WIP]
^.^|üü° link:https://github.com/cloudflare/pingora/issues/41[Issue]

|Language
^.^|image:c-logo.png[width=40, height=40]
^.^|image:go-logo.png[width=40, height=40]
^.^|image:go-logo.png[width=40, height=40]
^.^|image:rust-logo.png[width=40, height=40]
|===

==== Nginx Beispiel

.docker-compose.yml
[source, yaml]
----
services:
  nginx:
    container_name: nginx
    image: nginx:latest
    ports:
      - 80:80
    volumes:
      - ./conf.d:/etc/nginx/conf.d:ro
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    restart: unless-stopped

  nginx-echo:
    image: nodstuff/gecho:latest
    restart: unless-stopped
----

.conf.d/reverse-proxy.conf
[source, conf]
----
server {
    listen 80;

    server_name localhost;

    location /some-path {
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_pass http://nginx-echo:8080/;  # the trailing / is important...
    }
}

server {
    listen 80;

    server_name echo.localhost;

    location / {
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_pass http://nginx-echo:8080;
    }
}
----

.nginx.conf
[source, conf]
----
user www-data;
worker_processes auto;
pid /run/nginx.pid;

include /etc/nginx/modules-enabled/*.conf;

events {
    worker_connections 768;
    # multi_accept on;
}

http {

    ##
    # Basic Settings
    ##

    sendfile on;
    tcp_nopush on;
    types_hash_max_size 2048;

    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    ##
    # SSL Settings
    ##

    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE
    ssl_prefer_server_ciphers on;

    ##
    # Logging Settings
    ##

    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    ##
    # Gzip Settings
    ##

    gzip on;

    ##
    # Cache Settings
    ##

    proxy_cache_path /var/cache/nginx keys_zone=api-cache:10m;

    ##
    # Virtual Host Configs
    ##

    include /etc/nginx/conf.d/*.conf;
}
----

==== Traefik Beispiel

.docker-compose.yml
[source, yaml]
----
services:
  traefik:
    container_name: traefik
    image: traefik:latest
    environment:
      - TRAEFIK_API=true
      - TRAEFIK_API_INSECURE=true
      - TRAEFIK_PROVIDERS_DOCKER=true
      - LOG_LEVEL=DEBUG
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    ports:
      - 80:80
      - 8080:8080
    restart: unless-stopped
    labels:
      - traefik.http.routers.traefik.rule=Host(`localhost`)
      - traefik.http.services.traefik.loadbalancer.server.port=8080

  traefik-echo-1:
    image: nodstuff/gecho:latest
    restart: unless-stopped
    labels:
      - traefik.http.routers.echo-1.rule=Host(`localhost`) && PathPrefix(`/some-path`)
      - traefik.http.routers.echo-1.middlewares=replace-path@docker
      - traefik.http.middlewares.replace-path.replacepath.path=/
      - traefik.http.services.echo-1.loadbalancer.server.port=8080

  traefik-echo-2:
    image: nodstuff/gecho:latest
    restart: unless-stopped
    ports:
      - 8000:8080
    labels:
      - traefik.http.routers.echo-2.rule=Host(`echo.localhost`)
      # - traefik.http.services.echo.loadbalancer.server.port=8080
      # not needed because of traefik automatic service discovery magic
----

==== Caddy Beispiel

.docker-compose.yml
[source, yaml]
----
services:
  caddy:
    container_name: caddy
    image: caddy:latest
    cap_add:
      - NET_ADMIN
    volumes:
      - ./config:/etc/caddy
      - ./data:/data
    ports:
      - 80:80
      - 443:443
      - 443:443/udp # https://hub.docker.com/_/caddy Linux capabilities
    restart: unless-stopped

  caddy-echo:
    image: nodstuff/gecho:latest
    restart: unless-stopped
----

.config/Caddyfile
[source, Caddyfile]
----
echo.localhost {
	reverse_proxy caddy-echo:8080
}

localhost {
	handle /some-path*  {
		uri strip_prefix /some-path
		reverse_proxy caddy-echo:8080
	}
}
----

== Quellen
* Keycloak - Identity and Access Management for Modern Applications (Second Edition)
* https://quarkus.io/guides/security-keycloak-admin-client
* https://www.okta.com/de/identity-101/whats-the-difference-between-oauth-openid-connect-and-saml/
* https://www.microsoft.com/de-de/security/business/security-101/what-is-oauth
* https://auth0.com/de/intro-to-iam/what-is-oauth-2
* https://auth0.com/de/intro-to-iam/what-is-openid-connect-oidc
* https://auth0.com/de/intro-to-iam/what-is-saml
* https://www.keycloak.org/
* https://goauthentik.io/
* https://jwt.io/
* https://datatracker.ietf.org/doc/html/rfc7519#section-4.1
* https://traefik.io/glossary/reverse-proxy/ (a bissl marketing halluzinationen oba is ned so schlecht)
