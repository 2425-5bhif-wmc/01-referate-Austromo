= Security: Userverwaltung
Tobias J. Aichinger, Moritz V. Gruber, Lukas Sonnleitner
1.0, {docdate}
ifndef::sourcedir[:sourcedir: ../src/main/java]
ifndef::imagesdir[:imagesdir: images]
ifndef::backend[:backend: html5]
:icons: font
:sectnums:    // Nummerierung der √úberschriften / section numbering
:toc: left
:source-highlighter: rouge
:docinfo: shared

Standard Flow:

JWT:

* Wie es verschl√ºsselt worden
* Payload mit Daten drinnen
* Signature

Claim ist zB eine E-Mail
Scope ist eine collection von Claims

*Security* ist ein Begriff, welcher

== Authentifizierung und Autorisierung
Authentifizierung durch Eingabe von Username und Passwort ‚Üí *Wer bin ich?*

Durch Rollen ist man autorisiert, auf Ressourcen zuzugreifen ‚Üí *Was darf ich?*

== Rollen
image:roles.png[]

== Standards
=== OAuth 2.0
image:oauth2-logo.png[width=200]

[underline]#Bezeichnung#: O~pen~ Auth~orization~ 2.0

==== Definition
*OAuth 2.0* ist ein *Protokoll*, welches f√ºr die *Autorisierung* verantwortlich ist. Der Vorg√§nger *0Auth 1.0* wurde ausschlie√ülich f√ºr Webseiten entwickelt und wird nicht mehr h√§ufig verwendet.

Mehr Informationen link:https://auth0.com/de/intro-to-iam/what-is-oauth-2[hier^].

IMPORTANT: Die Authentifizierung von Benutzern wird bei OAuth 2.0 *nicht* abgedeckt.

image:oauth2-authorization-code-flow.png[]
TODO: Erkl√§rung

=== OIDC
image:oidc-logo.png[width=200]

[underline]#Bezeichnung#: O~pen~ID C~onnect~

==== Definition
*OIDC* ist ein *Protokoll*, welches auf 0Auth 2.0 aufbaut und eine zus√§tzliche Schicht f√ºr die *Authentifizierung* hinzuf√ºgt.

Mehr Informationen link:https://auth0.com/de/intro-to-iam/what-is-openid-connect-oidc[hier^].

image:oidc-authorization-code-flow.png[]
TODO: Erkl√§rung

=== SAML 2.0
image:saml-logo.png[width=200]

[underline]#Bezeichnung#: S~ecurity~ A~ssertion~ M~arkup~ L~anguage~ 2.0

==== Definition
*SAML 2.0* ist ein XML-basiertes Standardprotokoll f√ºr Authentifizierung und Autorisierung. Es wird h√§ufig verwendet, um Single Sign-On in Unternehmens- und Regierungsanwendungen zu erm√∂glichen. Das Protokoll erm√∂glicht es bestehenden Benutzern sich schnell und einfach in neuen Anwendungen zu authentifizieren.

Mehr Informationen link:https://auth0.com/de/intro-to-iam/what-is-saml[hier^].

=== JWT
image:jwt-logo.svg[width=200]

[underline]#Bezeichnung#: J~son~ W~eb~ T~oken~

==== Definition
*JSON Web Token* ist ein offener Standard, der eine kompakte M√∂glichkeit zur sicheren √úbertragung von Informationen zwischen Parteien als JSON-Objekt definiert. Diese Information wird digital *signiert* und sind somit vertrauensw√ºrdig.



==== Struktur
Ein JWT setzt sich aus 3 Teilen zusammen, welche jeweils durch einen `.` getrennt werden: `xxxxx.yyyyy.zzzzz`


===== Header: (`XXXXX`.yyyyy.zzzzz)

Besteht aus 2 Teilen:

.Beispiel
[source, json]
----
{
  "alg": "HS256", <.>
  "typ": "JWT" <.>
}
----
<.> Verwendeter Signieralgorithmus: link:https://stackoverflow.com/questions/39239051/rs256-vs-hs256-whats-the-difference[Unterschied zwischen *HS256* und *RS256*^]
<.> Typ des Tokens

Dieses JSON wird *Base64* verschl√ºsselt und macht somit den *ersten* Teil des JWTs aus.

===== Payload: (xxxxx.`YYYYY`.zzzzz)

Die Payload enth√§lt die Claims. *Claims* sind meistens Daten √ºber den User und zus√§tzliche Daten. Es gibt 3 Arten von Claims:

* *Registered* Claims: Vordefinierte Claims wie z. B. `exp` (expiration time) und noch link:https://datatracker.ietf.org/doc/html/rfc7519#section-4.1[mehr^]
* *Public* Claims: TODO
* *Private* Claims: Sind eigens *benutzerdefinierte* Claims, welche f√ºr den Informationsaustausch zweier Parteien fungieren.

.Beispiel
[source, json]
----
{
  "exp": "1734137921",
  "name": "John Doe",
  "admin": true
}
----

Dieses JSON wird *Base64* verschl√ºsselt und macht somit den *zweiten* Teil des JWTs aus.

===== Signature: (xxxxx.yyyyy.`ZZZZZ`)

Im dritten Part wird der `Header`, die `Payload` und ein `Secret` mit den im Header angegebenen Signieralgorithmus signiert.

.Beispiel f√ºr HS256
[source]
----
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)
----

Die Signatur kann sicherstellen, dass die Nachricht nicht von Dritten ge√§ndert wurde. Dies macht den *dritten* Teil des JWTs aus.

===== Zusammenfassung:

Das Ergebnis sind 3 Base64 Strings, welche durch einen `.` separiert werden.

Mehr Informationen link:https://jwt.io/introduction[hier^].

== Keycloak
=== Was ist Keycloak?
Keycloak ist eine *Open-Source*-Identity- und Access-Management-L√∂sung, die Funktionen wie Single Sign-On (SSO), Benutzerverwaltung und Social Login bietet.

IMPORTANT: *Single Sign-On* ist ein Authentifizierungsverfahren, bei dem Benutzer sich nur einmal anmelden und anschlie√üend auf mehrere Anwendungen oder Systeme zugreifen k√∂nnen, ohne sich erneut authentifizieren zu m√ºssen.

=== Alternativen

[%header, cols="1,1,1,1,1"]
|===
|
^.^|link:https://www.keycloak.org/[Keycloak^]
^.^|link:https://auth0.com/[Auth0^]
^.^|link:https://www.authelia.com/[Authelia^]
^.^|link:https://goauthentik.io/[authentik^]

^.^|*Open Source*
^.^|üü¢
^.^|üî¥
^.^|üü¢
^.^|üü¢

^.^|*Protocol Support:* OAuth 2.0 und OIDC
^.^|üü¢
^.^|üü¢
^.^|üü¢
^.^|üü¢

^.^|*Protocol Support:* SAML 2.0
^.^|üü¢
^.^|üü¢
^.^|üî¥
^.^|üü¢

^.^|*Language*
^.^|image:java-logo.png[width=40, height=40]
^.^|404
^.^|image:go-logo.png[width=40, height=40]
^.^|image:python-logo.png[width=40, height=40]
|===

=== Wichtigste Bestandteile in Keycloak

=== Custom Theme

== Keycloak mit dem quarkus-keycloak-admin-rest-client
F√ºr die Kommunikation zwischen der *Quarkus-Applikation* und *Keycloak* wird die link:https://quarkus.io/guides/security-keycloak-admin-client[quarkus-keycloak-admin-rest-client^] dependency verwendet. Der Rest-Client sendet Requests an die link:https://www.keycloak.org/docs-api/latest/rest-api/index.html[`Keycloak Admin REST API`^].

=== Projekterstellung
TODO: restlichen dependencies hinzuf√ºgen

.Projekterstellung mit Quarkus CLI
[source, shell]
----
quarkus create app at.htl:security-keycloak-admin-client \
    --extension='keycloak-admin-rest-client,rest-jackson' \
    --no-code
----

TODO: Version checken

.Projekterstellung mit Maven CLI
[source, shell]
----
mvn io.quarkus.platform:quarkus-maven-plugin:3.17.3:create \
    -DprojectGroupId=at.htl \
    -DprojectArtifactId=security-keycloak-admin-client \
    -Dextensions='keycloak-admin-rest-client,rest-jackson' \
    -DnoCode
----

.Dependencies aus pom.xml
[source, xml]
----
<!-- ... -->
<dependencies>
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-keycloak-admin-rest-client</artifactId>
    </dependency>
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-rest-jackson</artifactId>
    </dependency>
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-arc</artifactId>
    </dependency>
</dependencies>
<!-- ... -->
----

=== Keycloak Container starten

* `keycloak` Ordner auf der Ebene des Quarkus-Projekts erstellen

[source, shell]
----
mkdir keycloak
----

* Im `keycloak` Ordner eine Datei namens `docker-compose.yml` erstellen

[source, shell]
----
cd keycloak
touch docker-compose.yml
----

* Das `docker-compose.yml` mit folgendem Code bef√ºllen

[source, yaml]
----
services:
  keycloak: #<.>
    container_name: keycloak-demo #<.>
    image: quay.io/keycloak/keycloak:26.0.7 #<.>
    environment:
      - KEYCLOAK_ADMIN=admin #<.>
      - KEYCLOAK_ADMIN_PASSWORD=admin #<.>

      - KC_HOSTNAME_STRICT=false #<.>
      - KC_HTTP_ENABLED=true #<.>
      - KC_HOSTNAME=localhost #<.>
      - PROXY_ADDRESS_FORWARDING=true #<.>
      - KC_HEALTH_ENABLED=true #<.>
    command: ["start-dev"] #<.>
    ports:
      - "8000:8080" #<.>
----
.Erkl√§rung
[%collapsible]
====
<.> Der Name des Services
<.> Der Name des Containers
<.> Es wird die aktuellste Version `26.0.7` von Keycloak verwendet
<.> Umgebungsvariable f√ºr den Usernamen des Admins
<.> Umgebungsvariable f√ºr das Passwort des Admins
<.> TODO
<.> TODO
<.> TODO
<.> TODO
<.> TODO
<.> TODO
<.> Der *interne* Port auf der *rechten* Seite wird auf den *√§u√üeren* Port auf der *linken* Seite gemappt TODO
====

* Den Container mit folgendem Befehl starten

[source, shell]
----
docker compose up
----

* Nun kann auf `http://localhost:8000`, auf den laufenden Keycloak Container zugegriffen werden. In der Anmeldemaske kann man sich mithilfe der im `docker-compose.yml` angegebenen Username und Passwort als Admin anmelden.

.Anmeldemaske
[%collapsible]
====
image::keycloak-admin-login.png[]
====

.Admin-Konsole
[%collapsible]
====
image::keycloak-admin-console.png[]
====

=== Realm erstellen

IMPORTANT: TODO: Realm Beschreibung

Um einen *Realm* zu erstellen, muss man im linken oberen Eck auf das Dropdown und anschlie√üend auf den Button `Create realm` klicken.

.Realm erstellen Button
[%collapsible]
====
image::keycloak-create-realm-button.png[]
====

* Namen vergeben (z. B. my-realm)
* `Enabled` Option auf `On` lassen
* Auf den `Create` Button klicken

.Realm erstellen
[%collapsible]
====
image::keycloak-create-realm-window.png[]
====

=== Quarkus-Client erstellen

IMPORTANT: TODO: Client Beschreibung

Um einen *Client* zu erstellen, muss man im Clients Tab auf den `Create client` Button klicken.

.Client erstellen
[%collapsible]
====
image::keycloak-create-client-button.png[]
====

*General Settings*

* Als `Client ID` wird in diesem Beispiel der Name `quarkus-client` gew√§hlt
* Name und Description sind optional
* `Always display in UI` auf `On`, um Client dauerhaft im UI anzuzeigen

.Client erstellen - General Settings
[%collapsible]
====
image::keycloak-create-client-general-settings.png[]
====

*Capability config*

* `Client Authentication` auf `On` (TODO)
* `Authorization` auf `On` (TODO)
* `Authentication flow` (TODO)

.Client erstellen - Capability config
[%collapsible]
====
image::keycloak-create-client-capability-config.png[]
====

*Login settings*

TODO

* Standard flow
* [line-through]#Implicit flow#: deprecated

=== Probe
Nachdem nun ein *Realm* und ein *Client* in Keycloak existieren, k√∂nnen wir den *keycloak-admin-client* ausprobieren.

.application.properties
[source, properties]
----
# Quarkus keycloak-admin-client
quarkus.keycloak.admin-client.enabled=true <.>
quarkus.keycloak.admin-client.server-url=http://localhost:8000 <.>
quarkus.keycloak.admin-client.realm=my-realm <.>
quarkus.keycloak.admin-client.client-id=quarkus-client <.>
----
<.> true, wenn injection von Keycloak-Admin-Client unterst√ºtzt werden soll
<.> Die URL des Keycloak-Servers
<.> Der Name des Realms, worin sich der Client befindet
<.> Der Name des erstellten Clients

.Beispiels-Endpunkt
[source, java]
----
package at.htl.keycloakDemo.resources;

import jakarta.inject.Inject;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.Response;
import org.keycloak.admin.client.Keycloak;

@Path("/admin")
public class RolesResource {
    @Inject
    Keycloak keycloak;

    @GET
    @Path("/roles")
    public Response getRoles() {
        return Response.ok(
            keycloak
                .realm("my-realm")
                .roles()
                .list()
        ).build();
    }
}
----
TODO: Erkl√§rung

==== Response
[source, json]
----
{
  "details": "Error id bc6db0c5-e662-4e91-80e2-48e50026eb69-6, org.jboss.resteasy.reactive.ClientWebApplicationException: Received: 'Server response is: 401' when invoking REST Client method: 'org.keycloak.admin.client.token.TokenService#grantToken'"
}
----

Der Keycloak-Server gibt eine *401 - Unauthorized* Response zur√ºck. Um dies zu beheben, m√ºssen wir unsere *Quarkus-Applikation* mit dem Keycloak authentifizieren.

==== Authentifizierung
Es gibt 2 M√∂glichkeiten zur Authentifizierung mit dem *keycloak-admin-client*.

* password
* client-credentials

TODO: grant type erkl√§ren

===== Grant type: password
.application.properties
[source, properties]
----
# Quarkus keycloak-admin-client
quarkus.keycloak.admin-client.enabled=true
quarkus.keycloak.admin-client.server-url=http://localhost:8000
quarkus.keycloak.admin-client.realm=my-realm
quarkus.keycloak.admin-client.client-id=admin-cli <1>
quarkus.keycloak.admin-client.grant-type=password <2>
quarkus.keycloak.admin-client.username=alice <3>
quarkus.keycloak.admin-client.password=alice <3>
----
<.> F√ºr die `password` Variante muss die *client-id* auf `admin-cli` ge√§ndert werden. Dieser Admin-Client ist ein default client, auf welchem die *Client authentication* und *Authorization* ausgeschaltet sind. Allerdings brauchen wir diese bei dieser Variante nicht. TODO: √ºberpr√ºfen
<.> Setzt den *grant-type* auf `password`.
<.> Username und Passwort des erstellten Users.

.User erstellen
[%collapsible]
====
Im erstellten Realm auf `Users` -> `Add user` klicken.

WARNING: Obwohl nur *Username* ein Pflichtfeld ist, m√ºssen auch *Email*, *First name* und *Last name* ausgef√ºllt werden. Anderenfalls gibt Keycloak bei s√§mtlichen Requests einen *400 - Bad Request* zur√ºck.

image:keycloak-add-user.png[]
====

===== Grant type: client-credentials
.application.properties
[source, properties]
----
# Quarkus keycloak-admin-client
quarkus.keycloak.admin-client.enabled=true
quarkus.keycloak.admin-client.server-url=http://localhost:8000
quarkus.keycloak.admin-client.realm=my-realm
quarkus.keycloak.admin-client.client-id=quarkus-client
quarkus.keycloak.admin-client.grant-type=client-credentials <.>
quarkus.keycloak.admin-client.client-secret=<secret> <.>
----
<.> Legt fest, wie die Quarkus-Anwendung Zugangstokens von Keycloak erh√§lt, um administrative Aufgaben auszuf√ºhren. Hier wird der `client-credentials` type gemeinsam mit den *client-secret* benutzt.
<.> Der `client-secret` des erstellten Clients. Dieser ist unter folgendem Pfad zu finden: `Clients` -> `<client-name>` -> `Credentials` -> `Client Secret`

.Client secret
[%collapsible]
====
image:keycloak-client-secret.png[]
====

Jetzt probieren wir denselben Endpunkt nochmals aus.

==== Response
[source, json]
----
{
  "details": "Error id bc6db0c5-e662-4e91-80e2-48e50026eb69-5, org.jboss.resteasy.reactive.ClientWebApplicationException: Received: 'Server response is: 403' when invoking REST Client method: 'org.keycloak.admin.client.resource.RolesResource#list'"
}
----

Diesmal bekommen wir vom Keycloak-Server eine *403 - Forbidden* Response. Wir sind nun authentifiziert, allerdings ist der *quarkus-client* bzw. der User *alice* nicht autorisiert alle Rollen anzuzeigen.

==== Autorisierung
===== Grant type: password
Unter `Users` -> `<username>` -> `Role mapping` -> `Assign role` k√∂nnen dem User Rollen zugewiesen werden. Wir weisen dem User die Rolle `view-realm` zu, um *lesenden* Zugriff auf den *Realm* zu bekommen.

.User roles
[%collapsible]
====
image:keycloak-user-roles.png[]]
====

===== Grant type: client-credentials
Unter `Clients` -> `<client-name>` -> `Service accounts roles` -> `Assign role` k√∂nnen dem Client Rollen zugewiesen werden. Wir weisen dem Client die Rolle `view-realm` zu, um *lesenden* Zugriff auf den *Realm* zu bekommen.

.Client roles
[%collapsible]
====
image:keycloak-client-roles.png[]]
====

==== Response
[source, json]
----
[
  {
    "id": "1a6cc8e5-87ee-4871-a946-23f406bacea1",
    "name": "uma_authorization",
    "description": "${role_uma_authorization}",
    "scopeParamRequired": null,
    "composite": false,
    "composites": null,
    "clientRole": false,
    "containerId": "a22e79d4-1c88-4ce2-87a2-4757186910c1",
    "attributes": null
  },
  {
    "id": "6f822b0e-6db4-454d-a205-84f0bcd08aeb",
    "name": "offline_access",
    "description": "${role_offline-access}",
    "scopeParamRequired": null,
    "composite": false,
    "composites": null,
    "clientRole": false,
    "containerId": "a22e79d4-1c88-4ce2-87a2-4757186910c1",
    "attributes": null
  },
  {
    "id": "27fd8fbd-7bdf-4b5e-ad05-340a49c2c2f4",
    "name": "default-roles-my-realm",
    "description": "${role_default-roles}",
    "scopeParamRequired": null,
    "composite": true,
    "composites": null,
    "clientRole": false,
    "containerId": "a22e79d4-1c88-4ce2-87a2-4757186910c1",
    "attributes": null
  }
]
----

Jetzt werden die 3 default *Realm roles* als Response geliefert.

==== Zusammenfassung
TODO

== Demo

== Reverse Proxies

=== Was ist ein Reverse Proxy?

Ein Reverse Proxy ist ein Server, der die Anfragen von Clients zu einem oder mehreren Servern weiterleitet. +
Ein Reverse Proxy ist stellvertetend f√ºr die Server. +
Ein Proxy ist stellvertretend f√ºr die Clients.

.Reverse Proxy
image:reverse-proxy.svg[]

.Proxy
image:proxy.svg[]

=== Warum braucht man einen Reverse Proxy?

* Rate Limiting
* Routing
* Authentication
* Request Validierung
* Loadbalancing
* Caching
* Compression

=== Reverse Proxies im √úberblick

[%header, cols="1,1,1,1,1"]
|===
|
|link:https://nginx.org/en/[Nginx^]
|link:https://traefik.io/[Traefik^]
|link:https://caddyserver.com/[Caddy^]
|link:https://github.com/cloudflare/pingora[Pingora^]

|Benutzerfreundlichkeit
^.^|üü°
^.^|üü¢
^.^|üü¢
^.^|üî¥

|Configuration
|.conf
|.yaml +
.toml +
docker labels ... +
link:https://doc.traefik.io/traefik/providers/overview/#supported-providers[Alle Configurations Optionen]
|Caddyfile +
.json +
API
|Rust

|TLS/Https
|Manuell / Automatisiert mit Certbot
|Manuell / Automatisiert mit Certbot
|Automatisiert
|Manuell

|Kubernetes üòà
^.^|üü¢
^.^|üü¢
^.^|üü° link:https://github.com/caddyserver/ingress[WIP]
^.^|üü° link:https://github.com/cloudflare/pingora/issues/41[Issue]

|Language
^.^|image:c-logo.png[width=40, height=40]
^.^|image:go-logo.png[width=40, height=40]
^.^|image:go-logo.png[width=40, height=40]
^.^|image:rust-logo.png[width=40, height=40]
|===

==== Nginx Beispiel

.docker-compose.yml
[source, yaml]
----
services:
  nginx:
    container_name: nginx
    image: nginx:latest
    ports:
      - 80:80
    volumes:
      - ./conf.d:/etc/nginx/conf.d:ro
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    restart: unless-stopped

  nginx-echo:
    image: nodstuff/gecho:latest
    restart: unless-stopped
----

.conf.d/reverse-proxy.conf
[source, conf]
----
server {
    listen 80; <1>

    server_name localhost; <2>

    location /some-path/ { <3>
        proxy_set_header Host $http_host; <4>
        proxy_set_header X-Real-IP $remote_addr; <4>
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; <4>
        proxy_set_header X-Forwarded-Proto $scheme; <4>

        proxy_pass http://nginx-echo:8080/;  <5>
        # Der "/" am Ende ist wichtig. Ohne diesen w√ºrden Anfragen auf /some-path/ genau so weitergeleitet werden.
        # z.B. /some-path/i-love-turtles => /some-path/i-love-turtles
        # Mit dem "/" am Ende w√ºrde die Anfrage am Upstream Server so aussehen.
        # z.B. /some-path/i-love-turtles => /i-love-turtles
    }
}

server {
    listen 80; <1>

    server_name echo.localhost; <2>

    location / { <3>
        proxy_set_header Host $http_host; <4>
        proxy_set_header X-Real-IP $remote_addr; <4>
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; <4>
        proxy_set_header X-Forwarded-Proto $scheme; <4>

        proxy_pass http://nginx-echo:8080; <5>
    }
}
----
<1> Port auf den der Server h√∂rt
<2> Der `server_name` definiert, f√ºr welche Hostnamen dieser Serverblock gilt.
<3> Matched den Pfad und der Anfrage
<4> √úbertr√§gt die Header der urspr√ºnglichen Request an den Upstream-Server
<5> Leitet Anfragen an den Upstream-Server weiter.

.nginx.conf
[%collapsible]
====
[source, conf]
----
user www-data;
worker_processes auto;
pid /run/nginx.pid;

include /etc/nginx/modules-enabled/*.conf;

events {
    worker_connections 768;
    # multi_accept on;
}

http {

    ##
    # Basic Settings
    ##

    sendfile on;
    tcp_nopush on;
    types_hash_max_size 2048;

    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    ##
    # SSL Settings
    ##

    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE
    ssl_prefer_server_ciphers on;

    ##
    # Logging Settings
    ##

    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    ##
    # Gzip Settings
    ##

    gzip on;

    ##
    # Cache Settings
    ##

    ##
    # Virtual Host Configs
    ##

    include /etc/nginx/conf.d/*.conf;
}
----
====

==== Traefik Beispiel

.docker-compose.yml
[source, yaml]
----
services:
  traefik:
    container_name: traefik
    image: traefik:latest
    environment:
      - TRAEFIK_API=true
      - TRAEFIK_API_INSECURE=true
      - TRAEFIK_PROVIDERS_DOCKER=true
      - LOG_LEVEL=DEBUG
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    ports:
      - 80:80
      - 8080:8080
    restart: unless-stopped
    labels:
      - traefik.http.routers.traefik.rule=Host(`localhost`) <1>
      - traefik.http.services.traefik.loadbalancer.server.port=8080 <2>

  traefik-echo-1:
    image: nodstuff/gecho:latest
    restart: unless-stopped
    labels:
      - traefik.http.routers.echo-1.rule=Host(`localhost`) && PathPrefix(`/some-path`) <1>
      - traefik.http.routers.echo-1.middlewares=strip-prefix@docker <4>
      - traefik.http.middlewares.strip-prefix.stripprefix.prefixes=/some-path <3>
      - traefik.http.services.echo-1.loadbalancer.server.port=8080 <2>

  traefik-echo-2:
    image: nodstuff/gecho:latest
    restart: unless-stopped
    ports:
      - 8000:8080 <3>
    labels:
      - traefik.http.routers.echo-2.rule=Host(`echo.localhost`) <1>
      # - traefik.http.services.echo.loadbalancer.server.port=8080
      # not needed because of traefik automatic service discovery magic
----
<1> Definiert einen Router welcher aufgrund den definierten Regeln die Request an den Container weiterleitet
<2> Port auf den der Container h√∂rt
<3> Definiert eine Middleware, die den Prefix /some-path von den Anfragen wegschneidet
<4> Definert, dass der Router die middleware benutzen soll mit <name>@<provider> +
link:https://doc.traefik.io/traefik/middlewares/overview/[Mehr dazu] +
link:https://doc.traefik.io/traefik/providers/overview/[Providers]

===== Traefik Alternativ configuration

.traefik.toml
[source, yaml]
----
[http.middlewares]
[http.middlewares.strip-prefix.stripPrefix]
prefixes = ["/some-path"]
----

Mit dieser statischen Konfiguration w√ºrde der provider statt *docker* -> *file* sein.

==== Caddy Beispiel

.docker-compose.yml
[source, yaml]
----
services:
  caddy:
    container_name: caddy
    image: caddy:latest
    cap_add:
      - NET_ADMIN <1>
    volumes:
      - ./config:/etc/caddy
      - ./data:/data
    ports:
      - 80:80
      - 443:443
      - 443:443/udp # https://hub.docker.com/_/caddy Linux capabilities
    restart: unless-stopped

  caddy-echo:
    image: nodstuff/gecho:latest
    restart: unless-stopped
----

.config/Caddyfile
[source, Caddyfile]
----
echo.localhost { <1>
	reverse_proxy caddy-echo:8080 <3>
}

localhost { <1>
	handle /some-path*  { <2>
		uri strip_prefix /some-path <4>
		reverse_proxy caddy-echo:8080 <3>
	}
}
----
<1> Definieren die Domains oder Hostnamen, die von diesem Block verarbeitet werden.
<2> Matched den Pfad der Anfrage
<3> Leitet die Anfrage an den Upstream-Server weiter
<4> Schneidet den Prefix /some-path von dem Pfad der Anfrage weg

Caddy ist der einzige der 3 welcher automatisch TLS Zertifikate erstellt.
In dieser Demo sind diese selber signiert also nicht von einer Cerfificate Authority ausgestellt.

=== TLS? Warum brauch i sowas.

TLS oder auch *T*ransport *L*ayer *S*ecurity ist ein Verschl√ºsselungsprotokoll zur sicheren Daten√ºbertragung im Internet. +
link:https://tls13.xargs.org/#open-all[Wie funktioniert der genau?]

==== Wie bekomme ich so ein Zertifikat?

Ganz einfach. Selber machen.

[source, bash]
----
openssl genrsa -out private.key 4096 <1>
openssl req -new -key private.key -out request.csr -subj "/CN=DOMAIN_NAME" <2>
openssl x509 -req -days 365 -in request.csr -signkey private.key -out certificate.crt <3>
openssl dhparam -out dhparam.pem 4096 <4>

----
<1> Generiert einen 4096 byte langen private key
<2> Generiert eine Certifacet Signing Request (Zertifikt Unterschreibungs Anfrage) +
DOMAIN_NAME sollte mit der tats√§chlichen Domain ausgetauscht werden.
<3> Generiert das tats√§chliche Zertifikat welches f√ºr *365* Tage g√ºltig ist.
<4> Generiert eine 4096 byte lange Diffi-Hellman Parameter f√ºr den sicheren Schl√ºsselaustausch

==== Suppa. Wie benutzt ich das jetzt?

.conf.d/reverse-proxy.conf
[source, conf]
----
ssl_certificate /etc/ssl/certificate.crt;
ssl_certificate_key /etc/ssl/private.key;
ssl_dhparam /etc/nginx/dhparam.pem;
ssl_protocols TLSv1.3;

server {
    listen 443 ssl;

    server_name localhost;

    location /some-path/ {
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_pass http://nginx-echo:8080/;
    }
}

server {
    listen 443 ssl;

    server_name echo.localhost;

    location / {
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_pass http://nginx-echo:8080;
    }
}
----

So schwer war des jetzt ned. Wenn man im Browser jetzt *https*://echo.localhost aufruft wird man von dieser wundersch√∂nen Warnung begr√º√üt.

image:self-signed-warning.png[]

Was kann man dagegen tun? Nichts. Au√üer man benutzt Zertifikate die von sogenanten "Certifcate Authorities" ausgestellt werden. +
Daf√ºr braucht man eine √ñffentliche Domain, welche auf den Server zeigt, auf den der Reverse Proxy l√§uft.

Ein selbstsigniertes Zertifikat bedeutet, dass der Server selbst behauptet, seine Identit√§t und Inhalte seien vertrauensw√ºrdig. +
Es ist geeignet f√ºr Development Zwecke oder in internen Netzwerken, wenn keine CA die validit√§t versichern kann.

image:trust-me-bro.jpg[]

== Quellen
* Keycloak - Identity and Access Management for Modern Applications (Second Edition)
* https://quarkus.io/guides/security-keycloak-admin-client
* https://www.okta.com/de/identity-101/whats-the-difference-between-oauth-openid-connect-and-saml/
* https://www.microsoft.com/de-de/security/business/security-101/what-is-oauth
* https://auth0.com/de/intro-to-iam/what-is-oauth-2
* https://auth0.com/de/intro-to-iam/what-is-openid-connect-oidc
* https://auth0.com/de/intro-to-iam/what-is-saml
* https://www.keycloak.org/
* https://goauthentik.io/
* https://jwt.io/
* https://datatracker.ietf.org/doc/html/rfc7519#section-4.1
* https://traefik.io/glossary/reverse-proxy/ (a bissl marketing halluzinationen oba is ned so schlecht)
* https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/
