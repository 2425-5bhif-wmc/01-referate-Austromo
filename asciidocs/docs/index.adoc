= Security
Tobias J. Aichinger, Moritz V. Gruber, Lukas Sonnleitner
1.0, {docdate}
ifndef::sourcedir[:sourcedir: ../src/main/java]
ifndef::imagesdir[:imagesdir: images]
ifndef::backend[:backend: html5]
:icons: font
:sectnums:    // Nummerierung der √úberschriften / section numbering
:toc: left
:source-highlighter: rouge
:docinfo: shared

*Security* ist in der IT ein Begriff, der unz√§hlige Bereiche abdeckt. Diese Dokumentation widmet sich einerseits der Verwaltung und Sicherung von *Benutzeridentit√§ten* und *Zugriffsrechten* und andererseits *Reverse Proxies*.

== Authentifizierung und Autorisierung
Autor: *Moritz V. Gruber*

Authentifizierung durch Eingabe von Username und Passwort ‚Üí *Wer bin ich?*

Durch Rollen ist man autorisiert, auf Ressourcen zuzugreifen ‚Üí *Was darf ich?*

== Rollen
image:roles.png[]

== Standards
=== OAuth 2.0
image:oauth2-logo.png[width=200]

[underline]#Bezeichnung#: O~pen~ Auth~orization~ 2.0

==== Definition
*OAuth 2.0* ist ein *Protokoll*, welches f√ºr die *Autorisierung* verantwortlich ist. Der Vorg√§nger *0Auth 1.0* wurde ausschlie√ülich f√ºr Webseiten entwickelt und wird nicht mehr h√§ufig verwendet.

Mehr Informationen link:https://auth0.com/de/intro-to-iam/what-is-oauth-2[hier^].

IMPORTANT: Die Authentifizierung von Benutzern wird bei OAuth 2.0 *nicht* abgedeckt.

image:oauth2-authorization-code-flow.png[]

.Erkl√§rung
[%collapsible]
====
. Die [.green]#Applikation# fordert vom [.red]#Browser#, dass er den User zu [.gray]#Keycloak# umleitet.
. Der [.red]#Browser# leitet den User zu [.gray]#Keycloak# um.
. [.gray]#Keycloak# authentifiziert den User, falls er noch nicht mit [.gray]#Keycloak# authentifiziert ist.
. Die [.green]#Applikation# erh√§lt einen Autorisierungscode von [.gray]#Keycloak#.
. Die [.green]#Applikation# tauscht diesen Autorisierungscode gegen einen *Access-Token* von [.gray]#Keycloak# ein.
. Dieser Access-Token kann nun genutzt werden um auf *Ressourcen* auf dem [.blue]#Service# zuzugreifen.
====

=== OIDC
image:oidc-logo.png[width=200]

[underline]#Bezeichnung#: O~pen~ID C~onnect~

==== Definition
*OIDC* ist ein *Protokoll*, welches auf 0Auth 2.0 aufbaut und eine zus√§tzliche Schicht f√ºr die *Authentifizierung* hinzuf√ºgt.

Mehr Informationen link:https://auth0.com/de/intro-to-iam/what-is-openid-connect-oidc[hier^].

image:oidc-authorization-code-flow.png[]

.Erkl√§rung
[%collapsible]
====
. Die [.green]#Applikation# fordert vom [.red]#Browser#, dass er den User zu [.gray]#Keycloak# umleitet.
. Der [.red]#Browser# leitet den User zu [.gray]#Keycloak# um.
. [.gray]#Keycloak# authentifiziert den User, falls er noch nicht mit [.gray]#Keycloak# authentifiziert ist.
. Die [.green]#Applikation# erh√§lt einen Autorisierungscode von [.gray]#Keycloak#.
. Die [.green]#Applikation# tauscht diesen Autorisierungscode gegen einen *ID-Token* und einen *Access-Token* von [.gray]#Keycloak# ein.
. Die [.green]#Applikation# verf√ºgt nun √ºber den ID-Token, mit dem sie die Identit√§t des Benutzers ermitteln und eine authentifizierte Sitzung f√ºr den User aufbauen kann.
====

=== SAML 2.0
image:saml-logo.png[width=200]

[underline]#Bezeichnung#: S~ecurity~ A~ssertion~ M~arkup~ L~anguage~ 2.0

==== Definition
*SAML 2.0* ist ein XML-basiertes Standardprotokoll f√ºr Authentifizierung und Autorisierung. Es wird h√§ufig verwendet, um Single Sign-On in Unternehmens- und Regierungsanwendungen zu erm√∂glichen. Das Protokoll erm√∂glicht es bestehenden Benutzern sich schnell und einfach in neuen Anwendungen zu authentifizieren.

Mehr Informationen link:https://auth0.com/de/intro-to-iam/what-is-saml[hier^].

=== JWT
image:jwt-logo.svg[width=200]

[underline]#Bezeichnung#: J~son~ W~eb~ T~oken~

==== Definition
*JSON Web Token* ist ein offener Standard, der eine kompakte M√∂glichkeit zur sicheren √úbertragung von Informationen zwischen Parteien als JSON-Objekt definiert. Diese Information wird digital *signiert* und ist somit vertrauensw√ºrdig.



==== Struktur
Ein JWT setzt sich aus 3 Teilen zusammen, welche jeweils durch einen `.` getrennt werden: `xxxxx.yyyyy.zzzzz`


===== Header: (`XXXXX`.yyyyy.zzzzz)

Besteht aus 2 Teilen:

.Beispiel
[source, json]
----
{
  "alg": "HS256", <.>
  "typ": "JWT" <.>
}
----
<.> Verwendeter Signieralgorithmus: link:https://stackoverflow.com/questions/39239051/rs256-vs-hs256-whats-the-difference[Unterschied zwischen *HS256* und *RS256*^]
<.> Typ des Tokens

Dieses JSON wird *Base64* verschl√ºsselt und macht somit den *ersten* Teil des JWTs aus.

===== Payload: (xxxxx.`YYYYY`.zzzzz)

Die Payload enth√§lt die Claims. *Claims* sind meistens Daten √ºber den User und zus√§tzliche Daten. Es gibt 3 Arten von Claims:

* *Registered* Claims: Vordefinierte Claims wie z. B. `exp` (expiration time) und noch link:https://datatracker.ietf.org/doc/html/rfc7519#section-4.1[mehr^]
* *Public* Claims: Sind eigens *benutzerdefinierte* Claims, welche √∂ffentlich registriert werden. Dabei ist es wichtig darauf zu achten, dass keine Namenskonflikte entstehen.
* *Private* Claims: Sind eigens *benutzerdefinierte* Claims, welche nicht ver√∂ffentlicht werden.

.Beispiel
[source, json]
----
{
  "exp": "1734137921",
  "name": "John Doe",
  "admin": true
}
----

Dieses JSON wird *Base64* verschl√ºsselt und macht somit den *zweiten* Teil des JWTs aus.

===== Signature: (xxxxx.yyyyy.`ZZZZZ`)

Im dritten Part wird der `Header`, die `Payload` und ein `Secret` mit den im Header angegebenen Signieralgorithmus signiert.

.Beispiel f√ºr HS256
[source]
----
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)
----

Die Signatur kann sicherstellen, dass die Nachricht nicht von Dritten ge√§ndert wurde. Dies macht den *dritten* Teil des JWTs aus.

===== Zusammenfassung:

Das Ergebnis sind *3* *Base64* Strings, welche durch einen `.` separiert werden.

Mehr Informationen link:https://jwt.io/introduction[hier^].

== Keycloak
=== Was ist Keycloak?
Keycloak ist eine *Open-Source*-Identity- und Access-Management-L√∂sung, die Funktionen wie Single Sign-On (SSO), Benutzerverwaltung und Social Login bietet.

IMPORTANT: *Single Sign-On* ist ein Authentifizierungsverfahren, bei dem Benutzer sich nur einmal anmelden und anschlie√üend auf mehrere Anwendungen oder Systeme zugreifen k√∂nnen, ohne sich erneut authentifizieren zu m√ºssen.

=== Alternativen

[%header, cols="1,1,1,1,1"]
|===
|
^.^|link:https://www.keycloak.org/[Keycloak^]
^.^|link:https://auth0.com/[Auth0^]
^.^|link:https://www.authelia.com/[Authelia^]
^.^|link:https://goauthentik.io/[authentik^]

^.^|*Open Source*
^.^|üü¢
^.^|üî¥
^.^|üü¢
^.^|üü¢

^.^|*Protocol Support:* OAuth 2.0 und OIDC
^.^|üü¢
^.^|üü¢
^.^|üü¢
^.^|üü¢

^.^|*Protocol Support:* SAML 2.0
^.^|üü¢
^.^|üü¢
^.^|üî¥
^.^|üü¢

^.^|*Language*
^.^|image:java-logo.png[width=40, height=40]
^.^|404
^.^|image:go-logo.png[width=40, height=40]
^.^|image:python-logo.png[width=40, height=40]
|===

=== Wichtige Bestandteile in Keycloak
==== Realms
[quote, Keycloak, realm description]
____
A *realm* manages a set of users, credentials, roles, and groups. A user belongs to and logs into a realm. Realms are isolated from one another and can only manage and authenticate the users that they control.
____

==== Clients
[quote, Keycloak, client description]
____
*Clients* are applications and services that can request authentication of a user.
____

==== Realm roles
[quote, Keycloak, realm role description]
____
*Realm roles* are the roles that you define for use in the current realm.
____

==== Users
[quote, Keycloak, user description]
____
*Users* are the users in the current realm.
____

==== Groups
[quote, Keycloak, group description]
____
A *group* is a set of attributes and role mappings that can be applied to a user.
____

==== Sessions
[quote, Keycloak, session description]
____
*Sessions* are sessions of users in this realm and the clients that they access within the session.
____

== Keycloak mit dem quarkus-keycloak-admin-rest-client
F√ºr die Kommunikation zwischen der *Quarkus-Applikation* und *Keycloak* wird die link:https://quarkus.io/guides/security-keycloak-admin-client[quarkus-keycloak-admin-rest-client^] dependency verwendet. Der Rest-Client sendet Requests an die link:https://www.keycloak.org/docs-api/latest/rest-api/index.html[`Keycloak Admin REST API`^].

=== Projekterstellung
.Projekterstellung mit Quarkus CLI
[source, shell]
----
quarkus create app at.htl:security-keycloak-admin-client \
    --extension='keycloak-admin-rest-client,rest-jackson' \
    --no-code
----

.Projekterstellung mit Maven CLI
[source, shell]
----
mvn io.quarkus.platform:quarkus-maven-plugin:3.17.3:create \
    -DprojectGroupId=at.htl \
    -DprojectArtifactId=security-keycloak-admin-client \
    -Dextensions='keycloak-admin-rest-client,rest-jackson' \
    -DnoCode
----

.Dependencies aus pom.xml
[source, xml]
----
<!-- ... -->
<dependencies>
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-keycloak-admin-rest-client</artifactId>
    </dependency>
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-rest-jackson</artifactId>
    </dependency>
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-arc</artifactId>
    </dependency>
</dependencies>
<!-- ... -->
----

=== Keycloak Container starten

* `keycloak` Ordner auf der Ebene des Quarkus-Projekts erstellen

[source, shell]
----
mkdir keycloak
----

* Im `keycloak` Ordner eine Datei namens `docker-compose.yml` erstellen

[source, shell]
----
cd keycloak
touch docker-compose.yml
----

* Das `docker-compose.yml` mit folgendem Code bef√ºllen

[source, yaml]
----
services:
  keycloak:
    container_name: keycloak-demo #<.>
    build: #<.>
      context: .
      dockerfile: Dockerfile
    environment: #<.>
      - KEYCLOAK_ADMIN=admin
      - KEYCLOAK_ADMIN_PASSWORD=admin

      - KC_HOSTNAME_STRICT=false
      - KC_HTTP_ENABLED=true
      - KC_HOSTNAME=localhost

      - KC_DB=postgres
      - KC_DB_URL=jdbc:postgresql://keycloak-db/db
      - KC_DB_USERNAME=app
      - KC_DB_PASSWORD=app

      - KC_HEALTH_ENABLED=true
      - KC_METRICS_ENABLED=true
    command: ["start-dev", "--import-realm"] #<.>
    volumes:
      - ./import:/opt/keycloak/data/import #<.>
      - ./themes:/opt/keycloak/themes/ #<.>
    ports:
      - "8000:8080"
      - "9000:9000"
    depends_on:
      - keycloak-db

  keycloak-db: #<.>
    container_name: keycloak-db
    image: postgres:17.2
    restart: unless-stopped
    environment:
      - POSTGRES_USER=app
      - POSTGRES_PASSWORD=app
      - POSTGRES_DB=db
    volumes:
      - ./keycloak-db/data:/var/lib/postgresql/data
----
.Erkl√§rung
[%collapsible]
====
<.> Der Name des Containers
<.> F√ºr den Bauvorgang wird ein `Dockerfile` verwendet
<.> link:https://www.keycloak.org/server/all-config[Konfiguration in Keycloak^]
<.> `start-dev` um Keycloak im Dev-Modus zu starten und `--import-realm` um einen Realm zu importieren
<.> Bind mount f√ºr eine Realm-JSON Datei
<.> Bind mount f√ºr ein eigenes Theme
<.> Service f√ºr eine Datenbank
====

[source, dockerfile]
----
FROM quay.io/keycloak/keycloak:26.0.2 AS builder <1>
RUN /opt/keycloak/bin/kc.sh build

FROM quay.io/keycloak/keycloak:26.0.2 <1>
COPY --from=builder /opt/keycloak/ /opt/keycloak/
----
.Erkl√§rung
[%collapsible]
====
<1> Es wird die Version `26.0.2` verwendet, da die neuste Version (`26.0.7`) √Ñnderungen enth√§lt, welche die *keycloak-admin-rest-client* dependency in Quarkus noch nicht umgesetzt hat. (Stand: 2024-12-15)
====

* Den Container mit folgendem Befehl starten

[source, shell]
----
docker compose up
----

* Nun kann auf `http://localhost:8000`, auf den laufenden Keycloak Container zugegriffen werden. In der Anmeldemaske kann man sich mithilfe der im `docker-compose.yml` angegebenen Username und Passwort als Admin anmelden.

.Anmeldemaske
[%collapsible]
====
image::keycloak-admin-login.png[]
====

.Admin-Konsole
[%collapsible]
====
image::keycloak-admin-console.png[]
====

=== Realm erstellen
Um einen *Realm* zu erstellen, muss man im linken oberen Eck auf das Dropdown und anschlie√üend auf den Button `Create realm` klicken.

.Realm erstellen Button
[%collapsible]
====
image::keycloak-create-realm-button.png[]
====

* Namen vergeben (z. B. my-realm)
* `Enabled` Option auf `On` lassen
* Auf den `Create` Button klicken

.Realm erstellen
[%collapsible]
====
image::keycloak-create-realm-window.png[]
====

=== Quarkus-Client erstellen
Um einen *Client* zu erstellen, muss man im Clients Tab auf den `Create client` Button klicken.

.Client erstellen
[%collapsible]
====
image::keycloak-create-client-button.png[]
====

*General Settings*

* Als `Client ID` wird in diesem Beispiel der Name `quarkus-client` gew√§hlt
* Name und Description sind optional
* `Always display in UI` auf `On`, um Client dauerhaft im UI anzuzeigen

.Client erstellen - General Settings
[%collapsible]
====
image::keycloak-create-client-general-settings.png[]
====

*Capability config*

* [*] `Client Authentication`
* [*] `Authorization`
* `Authentication flow`
** [*] Standard flow
** [ ] Direct access grants
** [ ] Implicit flow
** [*] Service accounts roles
** [ ] OAuth 2.0 Device Authorization Grant
** [ ] OIDC CIBA Grant

Mehr Informationen link:https://www.keycloak.org/securing-apps/oidc-layers#_supported_grant_types[hier^].

.Client erstellen - Capability config
[%collapsible]
====
image::keycloak-create-client-capability-config.png[]
====

*Login settings*

leer lassen

=== Probe
Nachdem nun ein *Realm* und ein *Client* in Keycloak existieren, k√∂nnen wir den *keycloak-admin-rest-client* ausprobieren.

.application.properties
[source, properties]
----
# Quarkus keycloak-admin-client
quarkus.keycloak.admin-client.enabled=true <.>
quarkus.keycloak.admin-client.server-url=http://localhost:8000 <.>
quarkus.keycloak.admin-client.realm=my-realm <.>
quarkus.keycloak.admin-client.client-id=quarkus-client <.>
----
<.> true, wenn injection von Keycloak-Admin-Client unterst√ºtzt werden soll
<.> Die URL des Keycloak-Servers
<.> Der Name des Realms, worin sich der Client befindet
<.> Der Name des erstellten Clients

.Beispiels-Endpunkt
[source, java]
----
package at.htl.keycloakDemo.resources;

import jakarta.inject.Inject;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.Response;
import org.keycloak.admin.client.Keycloak;

@Path("/admin")
public class RolesResource {
    @Inject
    Keycloak keycloak; //<.>

    @GET
    @Path("/roles")
    public Response getRoles() { //<.>
        return Response.ok(
            keycloak
                .realm("my-realm")
                .roles()
                .list()
        ).build();
    }
}
----
<.> Ein Keycloak-Objekt wird injiziert.
<.> Endpunkt um alle Rollen des Realms `my-realm` zu bekommen.

==== Response
[source, json]
----
{
  "details": "Error id bc6db0c5-e662-4e91-80e2-48e50026eb69-6, org.jboss.resteasy.reactive.ClientWebApplicationException: Received: 'Server response is: 401' when invoking REST Client method: 'org.keycloak.admin.client.token.TokenService#grantToken'"
}
----

Der Keycloak-Server gibt eine *401 - Unauthorized* Response zur√ºck. Um dies zu beheben, m√ºssen wir unsere *Quarkus-Applikation* mit dem Keycloak authentifizieren.

==== Authentifizierung
Es gibt 2 M√∂glichkeiten zur Authentifizierung mit dem *keycloak-admin-client*.

* Grant type: password
* Grant type: client-credentials

IMPORTANT: Ein *grant type* bezeichnet die Art und Weise wie ein Client sich mit Keycloak authentifiziert.

===== Grant type: password
.application.properties
[source, properties]
----
# Quarkus keycloak-admin-client
quarkus.keycloak.admin-client.enabled=true
quarkus.keycloak.admin-client.server-url=http://localhost:8000
quarkus.keycloak.admin-client.realm=my-realm
quarkus.keycloak.admin-client.client-id=admin-cli <1>
quarkus.keycloak.admin-client.grant-type=password <2>
quarkus.keycloak.admin-client.username=alice <3>
quarkus.keycloak.admin-client.password=alice <3>
----
<.> F√ºr die `password` Variante muss die *client-id* auf `admin-cli` ge√§ndert werden. Dieser Admin-Client ist ein default client, auf welchem die *Client authentication* und *Authorization* ausgeschaltet sind. Allerdings brauchen wir diese bei dieser Variante nicht.
<.> Setzt den *grant-type* auf `password`.
<.> Username und Passwort des erstellten Users.

.User erstellen
[%collapsible]
====
Im erstellten Realm auf `Users` -> `Add user` klicken.

WARNING: Obwohl nur *Username* ein Pflichtfeld ist, m√ºssen auch *Email*, *First name* und *Last name* ausgef√ºllt werden. Anderenfalls gibt Keycloak bei s√§mtlichen Requests einen *400 - Bad Request* zur√ºck.

image:keycloak-add-user.png[]
====

===== Grant type: client-credentials
.application.properties
[source, properties]
----
# Quarkus keycloak-admin-client
quarkus.keycloak.admin-client.enabled=true
quarkus.keycloak.admin-client.server-url=http://localhost:8000
quarkus.keycloak.admin-client.realm=my-realm
quarkus.keycloak.admin-client.client-id=quarkus-client
quarkus.keycloak.admin-client.grant-type=client-credentials <.>
quarkus.keycloak.admin-client.client-secret=<secret> <.>
----
<.> Legt fest, wie die Quarkus-Anwendung Zugangstokens von Keycloak erh√§lt, um administrative Aufgaben auszuf√ºhren. Hier wird der `client-credentials` type gemeinsam mit den *client-secret* benutzt.
<.> Der `client-secret` des erstellten Clients. Dieser ist unter folgendem Pfad zu finden: `Clients` -> `<client-name>` -> `Credentials` -> `Client Secret`

.Client secret
[%collapsible]
====
image:keycloak-client-secret.png[]
====

Jetzt probieren wir denselben Endpunkt nochmals aus.

==== Response
[source, json]
----
{
  "details": "Error id bc6db0c5-e662-4e91-80e2-48e50026eb69-5, org.jboss.resteasy.reactive.ClientWebApplicationException: Received: 'Server response is: 403' when invoking REST Client method: 'org.keycloak.admin.client.resource.RolesResource#list'"
}
----

Diesmal bekommen wir vom Keycloak-Server eine *403 - Forbidden* Response. Wir sind nun authentifiziert, allerdings ist der *quarkus-client* bzw. der User *alice* nicht autorisiert alle Rollen anzuzeigen.

==== Autorisierung
===== Grant type: password
Unter `Users` -> `<username>` -> `Role mapping` -> `Assign role` k√∂nnen dem User Rollen zugewiesen werden. Wir weisen dem User die Rolle `view-realm` zu, um *lesenden* Zugriff auf den *Realm* zu bekommen.

.User roles
[%collapsible]
====
image:keycloak-user-roles.png[]]
====

===== Grant type: client-credentials
Unter `Clients` -> `<client-name>` -> `Service accounts roles` -> `Assign role` k√∂nnen dem Client Rollen zugewiesen werden. Wir weisen dem Client die Rolle `view-realm` zu, um *lesenden* Zugriff auf den *Realm* zu bekommen.

.Client roles
[%collapsible]
====
image:keycloak-client-roles.png[]]
====

==== Response
[source, json]
----
[
  {
    "id": "1a6cc8e5-87ee-4871-a946-23f406bacea1",
    "name": "uma_authorization",
    "description": "${role_uma_authorization}",
    "scopeParamRequired": null,
    "composite": false,
    "composites": null,
    "clientRole": false,
    "containerId": "a22e79d4-1c88-4ce2-87a2-4757186910c1",
    "attributes": null
  },
  {
    "id": "6f822b0e-6db4-454d-a205-84f0bcd08aeb",
    "name": "offline_access",
    "description": "${role_offline-access}",
    "scopeParamRequired": null,
    "composite": false,
    "composites": null,
    "clientRole": false,
    "containerId": "a22e79d4-1c88-4ce2-87a2-4757186910c1",
    "attributes": null
  },
  {
    "id": "27fd8fbd-7bdf-4b5e-ad05-340a49c2c2f4",
    "name": "default-roles-my-realm",
    "description": "${role_default-roles}",
    "scopeParamRequired": null,
    "composite": true,
    "composites": null,
    "clientRole": false,
    "containerId": "a22e79d4-1c88-4ce2-87a2-4757186910c1",
    "attributes": null
  }
]
----

Jetzt werden die 3 default *Realm roles* als Response geliefert.

CAUTION: Falls man Zugriffsrechte, f√ºr zum Beispiel das Kreieren von Realms ben√∂tigt muss man in den `application.properties` den Realm `master` angeben. In diesem gibt es zus√§tzliche Rollen, wie `Create realm` oder auch `admin` um die Realms zu verwalten.

== Custom Theme
Keycloak bietet eine M√∂glichkeit *custom Themes* in Form von *css* zu verwenden. Daf√ºr ben√∂tigt man eine Datei namens `theme.properties` und nat√ºrlich ein `styles.css`.

.theme.properties
[source, properties]
----
parent=keycloak <.>
import=common/keycloak <.>
styles=css/login.css css/styles.css <.>
----
<.> Das parent theme auf dem das custom Theme aufbaut
<.> Mit dem `import` k√∂nnen common Ressourcen importiert werden
<.> Alle hier angegeben Stylesheets werden f√ºr das custom Theme angewandt

.styles.css
[source, css]
----
h1 {
    color: red;
}
----

Um dieses Theme nun in Keycloak verwenden zu k√∂nnen m√ºssen wir eine spezifische Ordnerstruktur neben unserem `docker-compose.yml` anlegen:

image:custom-theme-folder-structure.png[]

Nun m√ºssen wir noch einen bind mount anlegen:

[source, yaml]
----
services:
  keycloak:
    # ...
    volumes:
      - ./themes:/opt/keycloak/themes/
    # ...
----

Nachdem man den Keycloak startet, kann man unter `<realm-name>` -> `Realm settings` -> `Themes` sein eigenes Theme ausw√§hlen.

.Vorher
[%collapsible]
====
image:keycloak-v2-theme.png[]
====

.Nachher
[%collapsible]
====
image:keycloak-custom-theme.png[]
====

Mehr zu custom Themes link:https://www.keycloak.org/docs/latest/server_development/#_themes[hier^].

== Demo

== Keycloak Authentication Flows
Autor: *Tobias J. Aichinger*

== Client erstellung

image::authentication-flow.png[]

* Was ist ein Flow und was ein Grant?
** Leicht gesagt handelt es sich bei beiden, um eine Methode um einen Zugriffstoken zu erhalten

* Standard flow (Authorization Code flow)

[%collapsible]
====
image::standard-flow.png[]
====

* Implicit flow
** *NICHT VERWENDEN*, weil der Browser direkt den access token bekommt und ihn bei einem redirect zu unserem backend den access token einfach in der URL setzt

* OAuth 2.0 Device Authorization Grant
** Wird f√ºr die Autorisierung f√ºr Ger√§te ohne Eingabemedien wie smart TVs verwendet
** Dies geschieht durch eine URL, die vom Ger√§t angezeigt wird und dann am smartphone oder tablet ge√∂ffnet werden muss (hierzu wird keine Kommunikation zwischen den beiden ger√§ten ben√∂tigt)

[%collapsible]
====
image::deviceflow.png[]
====

* OIDC CIBA (Client Initiated Backchannel Authentication) Grant
** Erfolgt durch ein externes autorisierungs Device des Benutzers

[%collapsible]
====
image::oidc-ciba-grant.png[]
====
* Direct access grants
** *NICHT VERWENDEN*, da es Anwendungen m√∂glich ist, Nutzerdaten zu sehen und es nicht wirklich Autorisierung ist, sondern Nachahmung

* Service accounts roles
** Um einen access token ohne Nutzer zu erhalten, also nur f√ºr den Client
** Eine m√∂gliche Anwendung k√∂nnte eine Wetter-API sein

[%collapsible]
====
image::service-client-grant.png[]
====

NOTE: Alle Flows die nicht verwendet werden sollten sind in OAuth 2.1 bereits deprecated.





















== Reverse Proxies
Autor: *Lukas Sonnleitner*

=== Was ist ein Reverse Proxy?

Ein Reverse Proxy ist ein Server, der die Anfragen von Clients zu einem oder mehreren Servern weiterleitet. +
Ein Reverse Proxy ist stellvertetend f√ºr die Server. +
Ein Proxy ist stellvertretend f√ºr die Clients.

.Reverse Proxy
image:reverse-proxy.svg[]

.Proxy
image:proxy.svg[]

=== Warum braucht man einen Reverse Proxy?

* Rate Limiting
* Routing
* Authentication
* Request Validierung
* Loadbalancing
* Caching
* Compression

=== Reverse Proxies im √úberblick

[%header, cols="1,1,1,1,1"]
|===
|
|link:https://nginx.org/en/[Nginx^]
|link:https://traefik.io/[Traefik^]
|link:https://caddyserver.com/[Caddy^]
|link:https://github.com/cloudflare/pingora[Pingora^]

|Benutzerfreundlichkeit
^.^|üü°
^.^|üü¢
^.^|üü¢
^.^|üî¥

|Configuration
|.conf
|.yaml +
.toml +
docker labels ... +
link:https://doc.traefik.io/traefik/providers/overview/#supported-providers[Alle Configurations Optionen]
|Caddyfile +
.json +
API
|Rust

|TLS/Https
|Manuell / Automatisiert mit Certbot
|Manuell / Automatisiert mit Certbot
|Automatisiert
|Manuell

|Kubernetes üòà
^.^|üü¢
^.^|üü¢
^.^|üü° link:https://github.com/caddyserver/ingress[WIP]
^.^|üü° link:https://github.com/cloudflare/pingora/issues/41[Issue]

|Language
^.^|image:c-logo.png[width=40, height=40]
^.^|image:go-logo.png[width=40, height=40]
^.^|image:go-logo.png[width=40, height=40]
^.^|image:rust-logo.png[width=40, height=40]
|===

==== Nginx Beispiel

image:reverse-proxy-demo.svg[]

.docker-compose.yml
[source, yaml]
----
services:
  nginx:
    container_name: nginx
    image: nginx:latest
    ports:
      - 80:80
    volumes:
      - ./conf.d:/etc/nginx/conf.d:ro
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    restart: unless-stopped

  nginx-echo:
    image: nodstuff/gecho:latest
    restart: unless-stopped
----

.conf.d/reverse-proxy.conf
[source, conf]
----
server {
    listen 80; <1>

    server_name localhost; <2>

    location /some-path/ { <3>
        proxy_set_header Host $http_host; <4>
        proxy_set_header X-Real-IP $remote_addr; <4>
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; <4>
        proxy_set_header X-Forwarded-Proto $scheme; <4>

        proxy_pass http://nginx-echo:8080/;  <5>
        # Der "/" am Ende ist wichtig. Ohne diesen w√ºrden Anfragen auf /some-path/ genau so weitergeleitet werden.
        # z.B. /some-path/i-love-turtles => /some-path/i-love-turtles
        # Mit dem "/" am Ende w√ºrde die Anfrage am Upstream Server so aussehen.
        # z.B. /some-path/i-love-turtles => /i-love-turtles
    }
}

server {
    listen 80; <1>

    server_name echo.localhost; <2>

    location / { <3>
        proxy_set_header Host $http_host; <4>
        proxy_set_header X-Real-IP $remote_addr; <4>
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; <4>
        proxy_set_header X-Forwarded-Proto $scheme; <4>

        proxy_pass http://nginx-echo:8080; <5>
    }
}
----
<1> Port auf den der Server h√∂rt
<2> Der `server_name` definiert, f√ºr welche Hostnamen dieser Serverblock gilt.
<3> Matched den Pfad und der Anfrage
<4> √úbertr√§gt die Header der urspr√ºnglichen Request an den Upstream-Server
<5> Leitet Anfragen an den Upstream-Server weiter.

.nginx.conf
[%collapsible]
====
[source, conf]
----
user www-data;
worker_processes auto;
pid /run/nginx.pid;

include /etc/nginx/modules-enabled/*.conf;

events {
    worker_connections 768;
    # multi_accept on;
}

http {

    ##
    # Basic Settings
    ##

    sendfile on;
    tcp_nopush on;
    types_hash_max_size 2048;

    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    ##
    # SSL Settings
    ##

    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE
    ssl_prefer_server_ciphers on;

    ##
    # Logging Settings
    ##

    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    ##
    # Gzip Settings
    ##

    gzip on;

    ##
    # Cache Settings
    ##

    ##
    # Virtual Host Configs
    ##

    include /etc/nginx/conf.d/*.conf;
}
----
====

==== Traefik Beispiel

.docker-compose.yml
[source, yaml]
----
services:
  traefik:
    container_name: traefik
    image: traefik:latest
    environment:
      - TRAEFIK_API=true
      - TRAEFIK_API_INSECURE=true
      - TRAEFIK_PROVIDERS_DOCKER=true
      - LOG_LEVEL=DEBUG
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    ports:
      - 80:80
      - 8080:8080
    restart: unless-stopped
    labels:
      - traefik.http.routers.traefik.rule=Host(`localhost`) <1>
      - traefik.http.services.traefik.loadbalancer.server.port=8080 <2>

  traefik-echo-1:
    image: nodstuff/gecho:latest
    restart: unless-stopped
    labels:
      - traefik.http.routers.echo-1.rule=Host(`localhost`) && PathPrefix(`/some-path`) <1>
      - traefik.http.routers.echo-1.middlewares=strip-prefix@docker <4>
      - traefik.http.middlewares.strip-prefix.stripprefix.prefixes=/some-path <3>
      - traefik.http.services.echo-1.loadbalancer.server.port=8080 <2>

  traefik-echo-2:
    image: nodstuff/gecho:latest
    restart: unless-stopped
    ports:
      - 8000:8080 <3>
    labels:
      - traefik.http.routers.echo-2.rule=Host(`echo.localhost`) <1>
      # - traefik.http.services.echo.loadbalancer.server.port=8080
      # not needed because of traefik automatic service discovery magic
----
<1> Definiert einen Router welcher aufgrund den definierten Regeln die Request an den Container weiterleitet
<2> Port auf den der Container h√∂rt
<3> Definiert eine Middleware, die den Prefix /some-path von den Anfragen wegschneidet
<4> Definert, dass der Router die middleware benutzen soll mit <name>@<provider> +
link:https://doc.traefik.io/traefik/middlewares/overview/[Mehr dazu] +
link:https://doc.traefik.io/traefik/providers/overview/[Providers]

===== Traefik Alternativ configuration

.traefik.toml
[source, yaml]
----
[http.middlewares]
[http.middlewares.strip-prefix.stripPrefix]
prefixes = ["/some-path"]
----

Mit dieser statischen Konfiguration w√ºrde der provider statt *docker* -> *file* sein.

==== Caddy Beispiel

.docker-compose.yml
[source, yaml]
----
services:
  caddy:
    container_name: caddy
    image: caddy:latest
    cap_add:
      - NET_ADMIN <1>
    volumes:
      - ./config:/etc/caddy
      - ./data:/data
    ports:
      - 80:80
      - 443:443
      - 443:443/udp # https://hub.docker.com/_/caddy Linux capabilities
    restart: unless-stopped

  caddy-echo:
    image: nodstuff/gecho:latest
    restart: unless-stopped
----

.config/Caddyfile
[source, Caddyfile]
----
echo.localhost { <1>
	reverse_proxy caddy-echo:8080 <3>
}

localhost { <1>
	handle /some-path*  { <2>
		uri strip_prefix /some-path <4>
		reverse_proxy caddy-echo:8080 <3>
	}
}
----
<1> Definieren die Domains oder Hostnamen, die von diesem Block verarbeitet werden.
<2> Matched den Pfad der Anfrage
<3> Leitet die Anfrage an den Upstream-Server weiter
<4> Schneidet den Prefix /some-path von dem Pfad der Anfrage weg

Caddy ist der einzige der 3 welcher automatisch TLS Zertifikate erstellt.
In dieser Demo sind diese selber signiert also nicht von einer Cerfificate Authority ausgestellt.

=== TLS? Warum brauch i sowas.

TLS oder auch *T*ransport *L*ayer *S*ecurity ist ein Verschl√ºsselungsprotokoll zur sicheren Daten√ºbertragung im Internet. +
link:https://tls13.xargs.org/#open-all[Wie funktioniert der genau?]

==== Wie bekomme ich so ein Zertifikat?

Ganz einfach. Selber machen.

[source, bash]
----
openssl genrsa -out private.key 4096 <1>
openssl req -new -key private.key -out request.csr -subj "/CN=DOMAIN_NAME" <2>
openssl x509 -req -days 365 -in request.csr -signkey private.key -out certificate.crt <3>
openssl dhparam -out dhparam.pem 4096 <4>

----
<1> Generiert einen 4096 byte langen private key
<2> Generiert eine Certifacet Signing Request (Zertifikt Unterschreibungs Anfrage) +
DOMAIN_NAME sollte mit der tats√§chlichen Domain ausgetauscht werden.
<3> Generiert das tats√§chliche Zertifikat welches f√ºr *365* Tage g√ºltig ist.
<4> Generiert eine 4096 byte lange Diffi-Hellman Parameter f√ºr den sicheren Schl√ºsselaustausch

==== Suppa. Wie benutzt ich das jetzt?

.conf.d/reverse-proxy.conf
[source, conf]
----
ssl_certificate /etc/ssl/certificate.crt;
ssl_certificate_key /etc/ssl/private.key;
ssl_dhparam /etc/nginx/dhparam.pem;
ssl_protocols TLSv1.3;

server {
    listen 443 ssl;

    server_name localhost;

    location /some-path/ {
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_pass http://nginx-echo:8080/;
    }
}

server {
    listen 443 ssl;

    server_name echo.localhost;

    location / {
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_pass http://nginx-echo:8080;
    }
}
----

So schwer war des jetzt ned. Wenn man im Browser jetzt *https*://echo.localhost aufruft wird man von dieser wundersch√∂nen Warnung begr√º√üt.

image:self-signed-warning.png[]

Was kann man dagegen tun? Nichts. Au√üer man benutzt Zertifikate die von sogenanten "Certifcate Authorities" ausgestellt werden. +
Daf√ºr braucht man eine √ñffentliche Domain, welche auf den Server zeigt, auf den der Reverse Proxy l√§uft.

Ein selbstsigniertes Zertifikat bedeutet, dass der Server selbst behauptet, seine Identit√§t und Inhalte seien vertrauensw√ºrdig. +
Es ist geeignet f√ºr Development Zwecke oder in internen Netzwerken, wenn keine CA die Validit√§t versichern kann.

image:trust-me-bro.jpg[]

==== Was ist eine Certifcate Authority

Eine Certificate Authority (Zertifikat Authorit√§t), ist ein Unternehmen oder eine Organisation, die die Validit√§t von Websiten, E-Mail-Adressen etc mithilfe von Zertifikaten sicherstellt, welche an kryptografische Schl√ºssel gebunden sind.

* DigiCert $26 p.M. link:https://www.digicert.com[ü§ë]
* Sectigo $67 p.a. link:https://www.sectigo.com/ssl-certificates-tls/compare[ü§ë]
* Let‚Äôs Encrypt link:https://letsencrypt.org/[ü¶Å]

Warum ein Zertifikat kaufen, wenn man es auch kostenlos bekommen kann?

TODO: Certificate Validation

==== Certbot

Certbot ist ein cli-tool, welches Zertifikate von Lets Encrypt holt. +
F√ºr die bequemlichkeit benutzen wir Certbot mit docker compose.

TODO: ACME

[IMPORTANT]
.Voraussetzungen
====
* eine *Domain*
** optional: eine statische IP Adresse
* Port *80* und *443* offen
====

In diesem Beispiel ist *DOMAIN* ein platzhalter f√ºr die wirkliche Domain.

.docker-compose.yml
[source, yaml]
----
services:
  nginx:
    container_name: nginx
    image: nginx:latest
    ports:
      - 80:80
      - 443:443
    volumes:
      - ./conf.d:/etc/nginx/conf.d:ro
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./certbot/www:/var/www/certbot:ro
      - ./certbot/conf:/etc/letsencrypt:ro
    restart: unless-stopped

  certbot:
    profiles:
      - certbot <1>
    container_name: cerbot
    image: certbot/certbot
    volumes:
      - ./certbot/www:/var/www/certbot:rw
      - ./certbot/conf:/etc/letsencrypt:rw

  nginx-echo:
    image: nodstuff/gecho:latest
    restart: unless-stopped
----
<1> Ich benutze hier Profiles damit bei dem `docker compose up` command der Certbot Container nicht mit gestartet wird.

.conf.d/reverse-proxy.conf
[source, yaml]
----
server {
    listen 80;

    server_name _;

    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }
}
----

.nginx.conf
[source, yaml]
----
user www-data;
worker_processes auto;
pid /run/nginx.pid;

include /etc/nginx/modules-enabled/*.conf;

events {
    worker_connections 768;
    # multi_accept on;
}

http {

    ##
    # Basic Settings
    ##

    sendfile on;
    tcp_nopush on;
    types_hash_max_size 2048;

    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    ##
    # SSL Settings
    ##

    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE
    ssl_prefer_server_ciphers on;

    ##
    # Logging Settings
    ##

    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    ##
    # Gzip Settings
    ##

    gzip on;

    ##
    # Cache Settings
    ##

    proxy_cache_path /var/cache/nginx keys_zone=api-cache:10m;

    ##
    # Virtual Host Configs
    ##

    include /etc/nginx/conf.d/*.conf;
}
----

Mit `docker compose up -d` werden die services gestartet.

[source, bash]
----
DOMAINS=DOMAIN,SUB.DOMAIN... docker compose run --rm certbot certonly \
	--webroot --webroot-path /var/www/certbot \
	--dry-run \
	-d $DOMAINS \
	--register-unsafely-without-email --agree-tos
----

Dieser Command startet den certbot service und testet ob die Austellung eines Zertifikates m√∂glich ist.

[source, bash]
----
DOMAINS=DOMAIN,SUB.DOMAIN... docker compose run --rm certbot certonly \
	--webroot --webroot-path /var/www/certbot \
	-d $DOMAINS \
	--register-unsafely-without-email --agree-tos
----

image:certbot-get-certificate.png[]

Die Zertifikate findet man unter `/etc/letsencrypt/live/DOMAIN/` +
Erg√§nzen wir also die `reverse-proxy.conf` um https hinzuzuf√ºgen.

.conf.d/reverse-proxy.conf
[source, conf]
----
server {
    listen 80;

    server_name _;

    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }

    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl;

    server_name DOMAIN;

    ssl_certificate /etc/letsencrypt/live/DOMAIN/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/DOMAIN/privkey.pem;

    location /some-path/ {
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_pass http://nginx-echo:8080/;  # the trailing / is important...
    }
}

server {
    listen 443 ssl;

    server_name echo.DOMAIN;

    ssl_certificate /etc/letsencrypt/live/DOMAIN/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/DOMAIN/privkey.pem;

    location / {
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_pass http://nginx-echo:8080;
    }
}
----

Starten sie den nginx Container neu und bewundern sie ihr neues Zertifikat ohne Warnung.

==== Traefik TLS

==== Nginx Ingress Controller

==== Traefik Ingress Controller

== Quellen
* Keycloak - Identity and Access Management for Modern Applications (Second Edition)
* https://quarkus.io/guides/security-keycloak-admin-client
* https://www.okta.com/de/identity-101/whats-the-difference-between-oauth-openid-connect-and-saml/
* https://www.microsoft.com/de-de/security/business/security-101/what-is-oauth
* https://auth0.com/de/intro-to-iam/what-is-oauth-2
* https://auth0.com/de/intro-to-iam/what-is-openid-connect-oidc
* https://auth0.com/de/intro-to-iam/what-is-saml
* https://www.keycloak.org/
* https://goauthentik.io/
* https://jwt.io/
* https://medium.com/@nishada/securing-a-javascript-app-using-keycloak-263fdbbc9d02
* https://datatracker.ietf.org/doc/html/rfc7519#section-4.1
* https://traefik.io/glossary/reverse-proxy/ (a bissl marketing halluzinationen oba is ned so schlecht)
* https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/
* https://stytch.com/blog/jwt-claims/
* https://www.keycloak.org/docs/latest/server_development
* https://www.ssldragon.com/de/blog/wie-werde-zertifizierungs-autoritaet/
