= Security
Tobias J. Aichinger, Moritz V. Gruber, Lukas Sonnleitner
1.0, {docdate}
ifndef::sourcedir[:sourcedir: ../src/main/java]
ifndef::imagesdir[:imagesdir: images]
ifndef::backend[:backend: html5]
:icons: font
:sectnums:    // Nummerierung der √úberschriften / section numbering
:toc: left
:source-highlighter: rouge
:docinfo: shared

*Security* ist in der IT ein Begriff, der unz√§hlige Bereiche abdeckt. Diese Dokumentation widmet sich einerseits der Verwaltung und Sicherung von *Benutzeridentit√§ten* und *Zugriffsrechten* und andererseits *Reverse Proxies*.

== Authentifizierung und Autorisierung
Autor: *Moritz V. Gruber*

Authentifizierung durch Eingabe von Username und Passwort ‚Üí *Wer bin ich?*

Durch Rollen ist man autorisiert, auf Ressourcen zuzugreifen ‚Üí *Was darf ich?*

== Rollen
image:roles.png[]

== Standards
=== OAuth 2.0
image:oauth2-logo.png[width=200]

[underline]#Bezeichnung#: O~pen~ Auth~orization~ 2.0

==== Definition
*OAuth 2.0* ist ein *Protokoll*, welches f√ºr die *Autorisierung* verantwortlich ist. Der Vorg√§nger *0Auth 1.0* wurde ausschlie√ülich f√ºr Webseiten entwickelt und wird nicht mehr h√§ufig verwendet.

Mehr Informationen link:https://auth0.com/de/intro-to-iam/what-is-oauth-2[hier^].

IMPORTANT: Die Authentifizierung von Benutzern wird bei OAuth 2.0 *nicht* abgedeckt.

image:oauth2-authorization-code-flow.png[]

.Erkl√§rung
[%collapsible]
====
. Die [.green]#Applikation# fordert vom [.red]#Browser#, dass er den User zu [.gray]#Keycloak# umleitet.
. Der [.red]#Browser# leitet den User zu [.gray]#Keycloak# um.
. [.gray]#Keycloak# authentifiziert den User, falls er noch nicht mit [.gray]#Keycloak# authentifiziert ist.
. Die [.green]#Applikation# erh√§lt einen Autorisierungscode von [.gray]#Keycloak#.
. Die [.green]#Applikation# tauscht diesen Autorisierungscode gegen einen *Access-Token* von [.gray]#Keycloak# ein.
. Dieser Access-Token kann nun genutzt werden um auf *Ressourcen* auf dem [.blue]#Service# zuzugreifen.
====

=== OIDC
image:oidc-logo.png[width=200]

[underline]#Bezeichnung#: O~pen~ID C~onnect~

==== Definition
*OIDC* ist ein *Protokoll*, welches auf 0Auth 2.0 aufbaut und eine zus√§tzliche Schicht f√ºr die *Authentifizierung* hinzuf√ºgt.

Mehr Informationen link:https://auth0.com/de/intro-to-iam/what-is-openid-connect-oidc[hier^].

image:oidc-authorization-code-flow.png[]

.Erkl√§rung
[%collapsible]
====
. Die [.green]#Applikation# fordert vom [.red]#Browser#, dass er den User zu [.gray]#Keycloak# umleitet.
. Der [.red]#Browser# leitet den User zu [.gray]#Keycloak# um.
. [.gray]#Keycloak# authentifiziert den User, falls er noch nicht mit [.gray]#Keycloak# authentifiziert ist.
. Die [.green]#Applikation# erh√§lt einen Autorisierungscode von [.gray]#Keycloak#.
. Die [.green]#Applikation# tauscht diesen Autorisierungscode gegen einen *ID-Token* und einen *Access-Token* von [.gray]#Keycloak# ein.
. Die [.green]#Applikation# verf√ºgt nun √ºber den ID-Token, mit dem sie die Identit√§t des Benutzers ermitteln und eine authentifizierte Sitzung f√ºr den User aufbauen kann.
====

=== SAML 2.0
image:saml-logo.png[width=200]

[underline]#Bezeichnung#: S~ecurity~ A~ssertion~ M~arkup~ L~anguage~ 2.0

==== Definition
*SAML 2.0* ist ein XML-basiertes Standardprotokoll f√ºr Authentifizierung und Autorisierung. Es wird h√§ufig verwendet, um Single Sign-On in Unternehmens- und Regierungsanwendungen zu erm√∂glichen. Das Protokoll erm√∂glicht es bestehenden Benutzern sich schnell und einfach in neuen Anwendungen zu authentifizieren.

Mehr Informationen link:https://auth0.com/de/intro-to-iam/what-is-saml[hier^].

=== JWT
image:jwt-logo.svg[width=200]

[underline]#Bezeichnung#: J~son~ W~eb~ T~oken~

==== Definition
*JSON Web Token* ist ein offener Standard, der eine kompakte M√∂glichkeit zur sicheren √úbertragung von Informationen zwischen Parteien als JSON-Objekt definiert. Diese Information wird digital *signiert* und ist somit vertrauensw√ºrdig.



==== Struktur
Ein JWT setzt sich aus 3 Teilen zusammen, welche jeweils durch einen `.` getrennt werden: `xxxxx.yyyyy.zzzzz`


===== Header: (`XXXXX`.yyyyy.zzzzz)

Besteht aus 2 Teilen:

.Beispiel
[source, json]
----
{
  "alg": "HS256", <.>
  "typ": "JWT" <.>
}
----
<.> Verwendeter Signieralgorithmus: link:https://stackoverflow.com/questions/39239051/rs256-vs-hs256-whats-the-difference[Unterschied zwischen *HS256* und *RS256*^]
<.> Typ des Tokens

Dieses JSON wird *Base64* verschl√ºsselt und macht somit den *ersten* Teil des JWTs aus.

===== Payload: (xxxxx.`YYYYY`.zzzzz)

Die Payload enth√§lt die Claims. *Claims* sind meistens Daten √ºber den User und zus√§tzliche Daten. Es gibt 3 Arten von Claims:

* *Registered* Claims: Vordefinierte Claims wie z. B. `exp` (expiration time) und noch link:https://datatracker.ietf.org/doc/html/rfc7519#section-4.1[mehr^]
* *Public* Claims: Sind eigens *benutzerdefinierte* Claims, welche √∂ffentlich registriert werden. Dabei ist es wichtig darauf zu achten, dass keine Namenskonflikte entstehen.
* *Private* Claims: Sind eigens *benutzerdefinierte* Claims, welche nicht ver√∂ffentlicht werden.

.Beispiel
[source, json]
----
{
  "exp": "1734137921",
  "name": "John Doe",
  "admin": true
}
----

Dieses JSON wird *Base64* verschl√ºsselt und macht somit den *zweiten* Teil des JWTs aus.

===== Signature: (xxxxx.yyyyy.`ZZZZZ`)

Im dritten Part wird der `Header`, die `Payload` und ein `Secret` mit den im Header angegebenen Signieralgorithmus signiert.

.Beispiel f√ºr HS256
[source]
----
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)
----

Die Signatur kann sicherstellen, dass die Nachricht nicht von Dritten ge√§ndert wurde. Dies macht den *dritten* Teil des JWTs aus.

===== Zusammenfassung:

Das Ergebnis sind *3* *Base64* Strings, welche durch einen `.` separiert werden.

Mehr Informationen link:https://jwt.io/introduction[hier^].

== Keycloak
=== Was ist Keycloak?
Keycloak ist eine *Open-Source*-Identity- und Access-Management-L√∂sung, die Funktionen wie Single Sign-On (SSO), Benutzerverwaltung und Social Login bietet.

IMPORTANT: *Single Sign-On* ist ein Authentifizierungsverfahren, bei dem Benutzer sich nur einmal anmelden und anschlie√üend auf mehrere Anwendungen oder Systeme zugreifen k√∂nnen, ohne sich erneut authentifizieren zu m√ºssen.

=== Alternativen

[%header, cols="1,1,1,1,1"]
|===
|
^.^|link:https://www.keycloak.org/[Keycloak^]
^.^|link:https://auth0.com/[Auth0^]
^.^|link:https://www.authelia.com/[Authelia^]
^.^|link:https://goauthentik.io/[authentik^]

^.^|*Open Source*
^.^|üü¢
^.^|üî¥
^.^|üü¢
^.^|üü¢

^.^|*Protocol Support:* OAuth 2.0 und OIDC
^.^|üü¢
^.^|üü¢
^.^|üü¢
^.^|üü¢

^.^|*Protocol Support:* SAML 2.0
^.^|üü¢
^.^|üü¢
^.^|üî¥
^.^|üü¢

^.^|*Language*
^.^|image:java-logo.png[width=40, height=40]
^.^|404
^.^|image:go-logo.png[width=40, height=40]
^.^|image:python-logo.png[width=40, height=40]
|===

=== Wichtige Bestandteile in Keycloak
==== Realms
[quote, Keycloak, realm description]
____
A *realm* manages a set of users, credentials, roles, and groups. A user belongs to and logs into a realm. Realms are isolated from one another and can only manage and authenticate the users that they control.
____

==== Clients
[quote, Keycloak, client description]
____
*Clients* are applications and services that can request authentication of a user.
____

==== Realm roles
[quote, Keycloak, realm role description]
____
*Realm roles* are the roles that you define for use in the current realm.
____

==== Users
[quote, Keycloak, user description]
____
*Users* are the users in the current realm.
____

==== Groups
[quote, Keycloak, group description]
____
A *group* is a set of attributes and role mappings that can be applied to a user.
____

==== Sessions
[quote, Keycloak, session description]
____
*Sessions* are sessions of users in this realm and the clients that they access within the session.
____

== Keycloak mit dem quarkus-keycloak-admin-rest-client
F√ºr die Kommunikation zwischen der *Quarkus-Applikation* und *Keycloak* wird die link:https://quarkus.io/guides/security-keycloak-admin-client[quarkus-keycloak-admin-rest-client^] dependency verwendet. Der Rest-Client sendet Requests an die link:https://www.keycloak.org/docs-api/latest/rest-api/index.html[`Keycloak Admin REST API`^].

=== Projekterstellung
.Projekterstellung mit Quarkus CLI
[source, shell]
----
quarkus create app at.htl:security-keycloak-admin-client \
    --extension='keycloak-admin-rest-client,rest-jackson' \
    --no-code
----

.Projekterstellung mit Maven CLI
[source, shell]
----
mvn io.quarkus.platform:quarkus-maven-plugin:3.17.3:create \
    -DprojectGroupId=at.htl \
    -DprojectArtifactId=security-keycloak-admin-client \
    -Dextensions='keycloak-admin-rest-client,rest-jackson' \
    -DnoCode
----

.Dependencies aus pom.xml
[source, xml]
----
<!-- ... -->
<dependencies>
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-keycloak-admin-rest-client</artifactId>
    </dependency>
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-rest-jackson</artifactId>
    </dependency>
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-arc</artifactId>
    </dependency>
</dependencies>
<!-- ... -->
----

=== Keycloak Container starten

* `keycloak` Ordner auf der Ebene des Quarkus-Projekts erstellen

[source, shell]
----
mkdir keycloak
----

* Im `keycloak` Ordner eine Datei namens `docker-compose.yml` erstellen

[source, shell]
----
cd keycloak
touch docker-compose.yml
----

* Das `docker-compose.yml` mit folgendem Code bef√ºllen

[source, yaml]
----
services:
  keycloak:
    container_name: keycloak-demo #<.>
    build: #<.>
      context: .
      dockerfile: Dockerfile
    environment: #<.>
      - KEYCLOAK_ADMIN=admin
      - KEYCLOAK_ADMIN_PASSWORD=admin

      - KC_HOSTNAME_STRICT=false
      - KC_HTTP_ENABLED=true
      - KC_HOSTNAME=localhost

      - KC_DB=postgres
      - KC_DB_URL=jdbc:postgresql://keycloak-db/db
      - KC_DB_USERNAME=app
      - KC_DB_PASSWORD=app

      - KC_HEALTH_ENABLED=true
      - KC_METRICS_ENABLED=true
    command: ["start-dev", "--import-realm"] #<.>
    volumes:
      - ./import:/opt/keycloak/data/import #<.>
      - ./themes:/opt/keycloak/themes/ #<.>
    ports:
      - "8000:8080"
      - "9000:9000"
    depends_on:
      - keycloak-db

  keycloak-db: #<.>
    container_name: keycloak-db
    image: postgres:17.2
    restart: unless-stopped
    environment:
      - POSTGRES_USER=app
      - POSTGRES_PASSWORD=app
      - POSTGRES_DB=db
    volumes:
      - ./keycloak-db/data:/var/lib/postgresql/data
----
.Erkl√§rung
[%collapsible]
====
<.> Der Name des Containers
<.> F√ºr den Bauvorgang wird ein `Dockerfile` verwendet
<.> link:https://www.keycloak.org/server/all-config[Konfiguration in Keycloak^]
<.> `start-dev` um Keycloak im Dev-Modus zu starten und `--import-realm` um einen Realm zu importieren
<.> Bind mount f√ºr eine Realm-JSON Datei
<.> Bind mount f√ºr ein eigenes Theme
<.> Service f√ºr eine Datenbank
====

[source, dockerfile]
----
FROM quay.io/keycloak/keycloak:26.0.2 AS builder <1>
RUN /opt/keycloak/bin/kc.sh build

FROM quay.io/keycloak/keycloak:26.0.2 <1>
COPY --from=builder /opt/keycloak/ /opt/keycloak/
----
.Erkl√§rung
[%collapsible]
====
<1> Es wird die Version `26.0.2` verwendet, da die neuste Version (`26.0.7`) √Ñnderungen enth√§lt, welche die *keycloak-admin-rest-client* dependency in Quarkus noch nicht umgesetzt hat. (Stand: 2024-12-15)
====

* Den Container mit folgendem Befehl starten

[source, shell]
----
docker compose up
----

* Nun kann auf `http://localhost:8000`, auf den laufenden Keycloak Container zugegriffen werden. In der Anmeldemaske kann man sich mithilfe der im `docker-compose.yml` angegebenen Username und Passwort als Admin anmelden.

.Anmeldemaske
[%collapsible]
====
image::keycloak-admin-login.png[]
====

.Admin-Konsole
[%collapsible]
====
image::keycloak-admin-console.png[]
====

=== Realm erstellen
Um einen *Realm* zu erstellen, muss man im linken oberen Eck auf das Dropdown und anschlie√üend auf den Button `Create realm` klicken.

.Realm erstellen Button
[%collapsible]
====
image::keycloak-create-realm-button.png[]
====

* Namen vergeben (z. B. my-realm)
* `Enabled` Option auf `On` lassen
* Auf den `Create` Button klicken

.Realm erstellen
[%collapsible]
====
image::keycloak-create-realm-window.png[]
====

=== Quarkus-Client erstellen
Um einen *Client* zu erstellen, muss man im Clients Tab auf den `Create client` Button klicken.

.Client erstellen
[%collapsible]
====
image::keycloak-create-client-button.png[]
====

*General Settings*

* Als `Client ID` wird in diesem Beispiel der Name `quarkus-client` gew√§hlt
* Name und Description sind optional
* `Always display in UI` auf `On`, um Client dauerhaft im UI anzuzeigen

.Client erstellen - General Settings
[%collapsible]
====
image::keycloak-create-client-general-settings.png[]
====

*Capability config*

* [*] `Client Authentication`
* [*] `Authorization`
* `Authentication flow`
** [*] Standard flow
** [ ] Direct access grants
** [ ] Implicit flow
** [*] Service accounts roles
** [ ] OAuth 2.0 Device Authorization Grant
** [ ] OIDC CIBA Grant

Mehr Informationen link:https://www.keycloak.org/securing-apps/oidc-layers#_supported_grant_types[hier^].

.Client erstellen - Capability config
[%collapsible]
====
image::keycloak-create-client-capability-config.png[]
====

*Login settings*

leer lassen

=== Probe
Nachdem nun ein *Realm* und ein *Client* in Keycloak existieren, k√∂nnen wir den *keycloak-admin-rest-client* ausprobieren.

.application.properties
[source, properties]
----
# Quarkus keycloak-admin-client
quarkus.keycloak.admin-client.enabled=true <.>
quarkus.keycloak.admin-client.server-url=http://localhost:8000 <.>
quarkus.keycloak.admin-client.realm=my-realm <.>
quarkus.keycloak.admin-client.client-id=quarkus-client <.>
----
<.> true, wenn injection von Keycloak-Admin-Client unterst√ºtzt werden soll
<.> Die URL des Keycloak-Servers
<.> Der Name des Realms, worin sich der Client befindet
<.> Der Name des erstellten Clients

.Beispiels-Endpunkt
[source, java]
----
package at.htl.keycloakDemo.resources;

import jakarta.inject.Inject;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.Response;
import org.keycloak.admin.client.Keycloak;

@Path("/admin")
public class RolesResource {
    @Inject
    Keycloak keycloak; //<.>

    @GET
    @Path("/roles")
    public Response getRoles() { //<.>
        return Response.ok(
            keycloak
                .realm("my-realm")
                .roles()
                .list()
        ).build();
    }
}
----
<.> Ein Keycloak-Objekt wird injiziert.
<.> Endpunkt um alle Rollen des Realms `my-realm` zu bekommen.

==== Response
[source, json]
----
{
  "details": "Error id bc6db0c5-e662-4e91-80e2-48e50026eb69-6, org.jboss.resteasy.reactive.ClientWebApplicationException: Received: 'Server response is: 401' when invoking REST Client method: 'org.keycloak.admin.client.token.TokenService#grantToken'"
}
----

Der Keycloak-Server gibt eine *401 - Unauthorized* Response zur√ºck. Um dies zu beheben, m√ºssen wir unsere *Quarkus-Applikation* mit dem Keycloak authentifizieren.

==== Authentifizierung
Es gibt 2 M√∂glichkeiten zur Authentifizierung mit dem *keycloak-admin-client*.

* Grant type: password
* Grant type: client-credentials

IMPORTANT: Ein *grant type* bezeichnet die Art und Weise wie ein Client sich mit Keycloak authentifiziert.

===== Grant type: password
.application.properties
[source, properties]
----
# Quarkus keycloak-admin-client
quarkus.keycloak.admin-client.enabled=true
quarkus.keycloak.admin-client.server-url=http://localhost:8000
quarkus.keycloak.admin-client.realm=my-realm
quarkus.keycloak.admin-client.client-id=admin-cli <1>
quarkus.keycloak.admin-client.grant-type=password <2>
quarkus.keycloak.admin-client.username=alice <3>
quarkus.keycloak.admin-client.password=alice <3>
----
<.> F√ºr die `password` Variante muss die *client-id* auf `admin-cli` ge√§ndert werden. Dieser Admin-Client ist ein default client, auf welchem die *Client authentication* und *Authorization* ausgeschaltet sind. Allerdings brauchen wir diese bei dieser Variante nicht.
<.> Setzt den *grant-type* auf `password`.
<.> Username und Passwort des erstellten Users.

.User erstellen
[%collapsible]
====
Im erstellten Realm auf `Users` -> `Add user` klicken.

WARNING: Obwohl nur *Username* ein Pflichtfeld ist, m√ºssen auch *Email*, *First name* und *Last name* ausgef√ºllt werden. Anderenfalls gibt Keycloak bei s√§mtlichen Requests einen *400 - Bad Request* zur√ºck.

image:keycloak-add-user.png[]
====

===== Grant type: client-credentials
.application.properties
[source, properties]
----
# Quarkus keycloak-admin-client
quarkus.keycloak.admin-client.enabled=true
quarkus.keycloak.admin-client.server-url=http://localhost:8000
quarkus.keycloak.admin-client.realm=my-realm
quarkus.keycloak.admin-client.client-id=quarkus-client
quarkus.keycloak.admin-client.grant-type=client-credentials <.>
quarkus.keycloak.admin-client.client-secret=<secret> <.>
----
<.> Legt fest, wie die Quarkus-Anwendung Zugangstokens von Keycloak erh√§lt, um administrative Aufgaben auszuf√ºhren. Hier wird der `client-credentials` type gemeinsam mit den *client-secret* benutzt.
<.> Der `client-secret` des erstellten Clients. Dieser ist unter folgendem Pfad zu finden: `Clients` -> `<client-name>` -> `Credentials` -> `Client Secret`

.Client secret
[%collapsible]
====
image:keycloak-client-secret.png[]
====

Jetzt probieren wir denselben Endpunkt nochmals aus.

==== Response
[source, json]
----
{
  "details": "Error id bc6db0c5-e662-4e91-80e2-48e50026eb69-5, org.jboss.resteasy.reactive.ClientWebApplicationException: Received: 'Server response is: 403' when invoking REST Client method: 'org.keycloak.admin.client.resource.RolesResource#list'"
}
----

Diesmal bekommen wir vom Keycloak-Server eine *403 - Forbidden* Response. Wir sind nun authentifiziert, allerdings ist der *quarkus-client* bzw. der User *alice* nicht autorisiert alle Rollen anzuzeigen.

==== Autorisierung
===== Grant type: password
Unter `Users` -> `<username>` -> `Role mapping` -> `Assign role` k√∂nnen dem User Rollen zugewiesen werden. Wir weisen dem User die Rolle `view-realm` zu, um *lesenden* Zugriff auf den *Realm* zu bekommen.

.User roles
[%collapsible]
====
image:keycloak-user-roles.png[]]
====

===== Grant type: client-credentials
Unter `Clients` -> `<client-name>` -> `Service accounts roles` -> `Assign role` k√∂nnen dem Client Rollen zugewiesen werden. Wir weisen dem Client die Rolle `view-realm` zu, um *lesenden* Zugriff auf den *Realm* zu bekommen.

.Client roles
[%collapsible]
====
image:keycloak-client-roles.png[]]
====

==== Response
[source, json]
----
[
  {
    "id": "1a6cc8e5-87ee-4871-a946-23f406bacea1",
    "name": "uma_authorization",
    "description": "${role_uma_authorization}",
    "scopeParamRequired": null,
    "composite": false,
    "composites": null,
    "clientRole": false,
    "containerId": "a22e79d4-1c88-4ce2-87a2-4757186910c1",
    "attributes": null
  },
  {
    "id": "6f822b0e-6db4-454d-a205-84f0bcd08aeb",
    "name": "offline_access",
    "description": "${role_offline-access}",
    "scopeParamRequired": null,
    "composite": false,
    "composites": null,
    "clientRole": false,
    "containerId": "a22e79d4-1c88-4ce2-87a2-4757186910c1",
    "attributes": null
  },
  {
    "id": "27fd8fbd-7bdf-4b5e-ad05-340a49c2c2f4",
    "name": "default-roles-my-realm",
    "description": "${role_default-roles}",
    "scopeParamRequired": null,
    "composite": true,
    "composites": null,
    "clientRole": false,
    "containerId": "a22e79d4-1c88-4ce2-87a2-4757186910c1",
    "attributes": null
  }
]
----

Jetzt werden die 3 default *Realm roles* als Response geliefert.

CAUTION: Falls man Zugriffsrechte, f√ºr zum Beispiel das Kreieren von Realms ben√∂tigt muss man in den `application.properties` den Realm `master` angeben. In diesem gibt es zus√§tzliche Rollen, wie `Create realm` oder auch `admin` um die Realms zu verwalten.

== Custom Theme
Keycloak bietet eine M√∂glichkeit *custom Themes* in Form von *css* zu verwenden. Daf√ºr ben√∂tigt man eine Datei namens `theme.properties` und nat√ºrlich ein `styles.css`.

.theme.properties
[source, properties]
----
parent=keycloak <.>
import=common/keycloak <.>
styles=css/login.css css/styles.css <.>
----
<.> Das parent theme auf dem das custom Theme aufbaut
<.> Mit dem `import` k√∂nnen common Ressourcen importiert werden
<.> Alle hier angegeben Stylesheets werden f√ºr das custom Theme angewandt

.styles.css
[source, css]
----
h1 {
    color: red;
}
----

Um dieses Theme nun in Keycloak verwenden zu k√∂nnen m√ºssen wir eine spezifische Ordnerstruktur neben unserem `docker-compose.yml` anlegen:

image:custom-theme-folder-structure.png[]

Nun m√ºssen wir noch einen bind mount anlegen:

[source, yaml]
----
services:
  keycloak:
    # ...
    volumes:
      - ./themes:/opt/keycloak/themes/
    # ...
----

Nachdem man den Keycloak startet, kann man unter `<realm-name>` -> `Realm settings` -> `Themes` sein eigenes Theme ausw√§hlen.

.Vorher
[%collapsible]
====
image:keycloak-v2-theme.png[]
====

.Nachher
[%collapsible]
====
image:keycloak-custom-theme.png[]
====

Mehr zu custom Themes link:https://www.keycloak.org/docs/latest/server_development/#_themes[hier^].

== Demo

== Keycloak Authentication Flows
Autor: *Tobias J. Aichinger*

== Client erstellung

image::authentication-flow.png[]

* Was ist ein Flow und was ein Grant?
** Leicht gesagt handelt es sich bei beiden, um eine Methode um einen Zugriffstoken zu erhalten

* Standard flow (Authorization Code flow)

[%collapsible]
====
image::standard-flow.png[]
====

* Implicit flow
** *NICHT VERWENDEN*, weil der Browser direkt den access token bekommt und ihn bei einem redirect zu unserem backend den access token einfach in der URL setzt

* OAuth 2.0 Device Authorization Grant
** Wird f√ºr die Autorisierung f√ºr Ger√§te ohne Eingabemedien wie smart TVs verwendet
** Dies geschieht durch eine URL, die vom Ger√§t angezeigt wird und dann am smartphone oder tablet ge√∂ffnet werden muss (hierzu wird keine Kommunikation zwischen den beiden ger√§ten ben√∂tigt)

[%collapsible]
====
image::deviceflow.png[]
====

* OIDC CIBA (Client Initiated Backchannel Authentication) Grant
** Erfolgt durch ein externes autorisierungs Device des Benutzers

[%collapsible]
====
image::oidc-ciba-grant.png[]
====
* Direct access grants
** *NICHT VERWENDEN*, da es Anwendungen m√∂glich ist, Nutzerdaten zu sehen und es nicht wirklich Autorisierung ist, sondern Nachahmung

* Service accounts roles
** Um einen access token ohne Nutzer zu erhalten, also nur f√ºr den Client
** Eine m√∂gliche Anwendung k√∂nnte eine Wetter-API sein

[%collapsible]
====
image::service-client-grant.png[]
====

NOTE: Alle Flows die nicht verwendet werden sollten sind in OAuth 2.1 bereits deprecated.

=== Flow konfigurierung

Diese Flows beschreiben nun welche Schritte f√ºr die Authentifizierung in verschiedenen Umgebung verwendet werden. Unten sind die Flows welche von Keycloak bereits implementiert wurden und einfach verwendet werden k√∂nnen.

image::built-in-flows.png[]

Der "Create flow" button tut, was er sagt und erstellt einen Leeren Flow dies wird von Keycloak nicht empfohlen, da man eher bestehende Flows Duplizieren soll. Wenn ein Flow dann Editieren oder Ansehen will, kann auf den Namen gedr√ºckt werden, um diese Ansicht zu √∂ffnen:

image::browser-flow-1.png[]
image::browser-flow-2.png[]

Hier kann man den Aufbau von Flows gut sehen den:

* Steps
** Sind hierarchisch aufgebaut
** K√∂nnen weiter Untergeordnete schritte haben
** Beliebig verschiebbar

* Requirements
** Required: muss erfolgreich Ausgef√ºhrt werden
** Optional: wenn es der User konfiguriert hat, sonst wird es ignoriert
** Disabled: wird nicht ausgef√ºhrt
** Alternative: es muss mindestendes ein Authentifizierungstyp auf dieser Ebene erfolgreich sein

==== Custom Authenticator























== Reverse Proxies
Autor: *Lukas Sonnleitner*

=== Was ist ein Reverse Proxy?

Ein Reverse Proxy ist ein Server, der die Anfragen von Clients (z. B. Browsern) entgegennimmt und diese an einen oder mehrere Upstream-Server weiterleitet. Er fungiert als eine Art "Schutzschild" f√ºr Server, indem er:

* Anonymit√§t f√ºr die Server wahrt, da die Clients keine direkte Verbindung zu den Back-End-Servern herstellen.
* Sicherheit erh√∂ht, indem er als erste Verteidigungslinie gegen potenzielle Angriffe dient.

.Reverse Proxy
image:reverse-proxy.svg[]

Zum Vergleich: Ein "normaler" Proxy-Server arbeitet stellvertretend f√ºr die Clients, w√§hrend ein Reverse Proxy im Auftrag der Server agiert.

.Proxy
image:proxy.svg[]

=== Warum braucht man einen Reverse Proxy?

* *Rate* Limiting: Begrenzung der Anzahl von Anfragen pro Zeitspanne, um Missbrauch zu verhindern.
* *Routing*: Weiterleitung von Anfragen an spezifische Server oder Dienste basierend auf Regeln.
* *Authentication*: √úberpr√ºfung von Benutzeranfragen vor der Weiterleitung.
* *Request-Validierung*: Sicherstellen, dass Anfragen g√ºltig und sicher sind.
* *Loadbalancing*: Gleichm√§√üige Verteilung von Anfragen auf mehrere Server.
* *Caching*: Zwischenspeichern von Antworten, um die Leistung zu steigern.
* *Kompression*: Reduzieren der Datenmenge durch Komprimierung von Antworten.

=== Reverse Proxies im √úberblick

[%header, cols="1,1,1,1,1"]
|===
|
|link:https://nginx.org/en/[Nginx^]
|link:https://traefik.io/[Traefik^]
|link:https://caddyserver.com/[Caddy^]
|link:https://github.com/cloudflare/pingora[Pingora^]

|Benutzerfreundlichkeit
^.^|üü°
^.^|üü¢
^.^|üü¢
^.^|üî¥

|Configuration
|.conf
|.yaml +
.toml +
docker labels ... +
link:https://doc.traefik.io/traefik/providers/overview/#supported-providers[Alle Configurations Optionen]
|Caddyfile +
.json +
API
|Rust

|TLS/Https
|Manuell / Automatisiert mit Certbot
|Manuell / Automatisiert mit Certbot
|Automatisiert
|Manuell

|Kubernetes üòà
^.^|üü¢
^.^|üü¢
^.^|üü° link:https://github.com/caddyserver/ingress[WIP]
^.^|üü° link:https://github.com/cloudflare/pingora/issues/41[Issue]

|Language
^.^|image:c-logo.png[width=40, height=40]
^.^|image:go-logo.png[width=40, height=40]
^.^|image:go-logo.png[width=40, height=40]
^.^|image:rust-logo.png[width=40, height=40]
|===

=== Beispiele

image:reverse-proxy-demo.svg[]

==== Nginx http

.docker-compose.yml
[%collapsible]
====
[source, yaml]
----
services:
  nginx:
    container_name: nginx
    image: nginx:latest
    ports:
      - 80:80
    volumes:
      - ./conf.d:/etc/nginx/conf.d:ro
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    restart: unless-stopped

  nginx-echo:
    image: nodstuff/gecho:latest
    restart: unless-stopped
----
====

.conf.d/reverse-proxy.conf
[source, conf]
----
server {
    listen 80; <1>

    server_name localhost; <2>

    location /some-path/ { <3>
        proxy_set_header Host $http_host; <4>
        proxy_set_header X-Real-IP $remote_addr; <4>
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; <4>
        proxy_set_header X-Forwarded-Proto $scheme; <4>

        proxy_pass http://nginx-echo:8080/;  <5>
        # Der "/" am Ende ist wichtig. Ohne diesen w√ºrden Anfragen auf /some-path/ genau so weitergeleitet werden.
        # z.B. /some-path/i-love-turtles => /some-path/i-love-turtles
        # Mit dem "/" am Ende w√ºrde die Anfrage am Upstream Server so aussehen.
        # z.B. /some-path/i-love-turtles => /i-love-turtles
    }
}

server {
    listen 80; <1>

    server_name echo.localhost; <2>

    location / { <3>
        proxy_set_header Host $http_host; <4>
        proxy_set_header X-Real-IP $remote_addr; <4>
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; <4>
        proxy_set_header X-Forwarded-Proto $scheme; <4>

        proxy_pass http://nginx-echo:8080; <5>
    }
}
----
<1> Port auf den der Server h√∂rt
<2> Der `server_name` definiert, f√ºr welche Hostnamen dieser Serverblock gilt.
<3> Matched den Pfad und der Anfrage
<4> √úbertr√§gt die Header der urspr√ºnglichen Request an den Upstream-Server
<5> Leitet Anfragen an den Upstream-Server weiter.

.nginx.conf
[%collapsible]
====
[source, conf]
----
user www-data;
worker_processes auto;
pid /run/nginx.pid;

include /etc/nginx/modules-enabled/*.conf;

events {
    worker_connections 768;
    # multi_accept on;
}

http {

    ##
    # Basic Settings
    ##

    sendfile on;
    tcp_nopush on;
    types_hash_max_size 2048;

    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    ##
    # SSL Settings
    ##

    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE
    ssl_prefer_server_ciphers on;

    ##
    # Logging Settings
    ##

    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    ##
    # Gzip Settings
    ##

    gzip on;

    ##
    # Cache Settings
    ##

    ##
    # Virtual Host Configs
    ##

    include /etc/nginx/conf.d/*.conf;
}
----
====

==== Traefik http

.docker-compose.yml
[source, yaml]
----
services:
  traefik:
    container_name: traefik
    image: traefik:latest
    environment:
      - TRAEFIK_API=true
      - TRAEFIK_API_INSECURE=true
      - TRAEFIK_PROVIDERS_DOCKER=true
      - LOG_LEVEL=DEBUG
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    ports:
      - 80:80
      - 8080:8080
    restart: unless-stopped
    labels:
      - traefik.http.routers.traefik.rule=Host(`localhost`) <1>
      - traefik.http.services.traefik.loadbalancer.server.port=8080 <2>

  traefik-echo-1:
    image: nodstuff/gecho:latest
    restart: unless-stopped
    labels:
      - traefik.http.routers.echo-1.rule=Host(`localhost`) && PathPrefix(`/some-path`) <1>
      - traefik.http.routers.echo-1.middlewares=strip-prefix@docker <4>
      - traefik.http.middlewares.strip-prefix.stripprefix.prefixes=/some-path <3>
      - traefik.http.services.echo-1.loadbalancer.server.port=8080 <2>

  traefik-echo-2:
    image: nodstuff/gecho:latest
    restart: unless-stopped
    ports:
      - 8000:8080 <3>
    labels:
      - traefik.http.routers.echo-2.rule=Host(`echo.localhost`) <1>
      # - traefik.http.services.echo.loadbalancer.server.port=8080
      # not needed because of traefik automatic service discovery magic
----
<1> Definiert einen Router welcher aufgrund den definierten Regeln die Request an den Container weiterleitet
<2> Port auf den der Container h√∂rt
<3> Definiert eine Middleware, die den Prefix /some-path von den Anfragen wegschneidet
<4> Definert, dass der Router die middleware benutzen soll mit <name>@<provider> +
link:https://doc.traefik.io/traefik/middlewares/overview/[Mehr dazu] +
link:https://doc.traefik.io/traefik/providers/overview/[Providers]

===== Traefik Alternativ configuration

.traefik.toml
[source, yaml]
----
[http.middlewares]
[http.middlewares.strip-prefix.stripPrefix]
prefixes = ["/some-path"]
----

Mit dieser statischen Konfiguration w√ºrde der provider statt *docker* -> *file* sein.

==== Caddy (http / https)

.docker-compose.yml
[source, yaml]
----
services:
  caddy:
    container_name: caddy
    image: caddy:latest
    cap_add:
      - NET_ADMIN <1>
    volumes:
      - ./config:/etc/caddy
      - ./data:/data
    ports:
      - 80:80
      - 443:443
      - 443:443/udp # https://hub.docker.com/_/caddy Linux capabilities
    restart: unless-stopped

  caddy-echo:
    image: nodstuff/gecho:latest
    restart: unless-stopped
----

.config/Caddyfile
[source, Caddyfile]
----
echo.localhost { <1>
	reverse_proxy caddy-echo:8080 <3>
}

localhost { <1>
	handle /some-path*  { <2>
		uri strip_prefix /some-path <4>
		reverse_proxy caddy-echo:8080 <3>
	}
}
----
<1> Definieren die Domains oder Hostnamen, die von diesem Block verarbeitet werden.
<2> Matched den Pfad der Anfrage
<3> Leitet die Anfrage an den Upstream-Server weiter
<4> Schneidet den Prefix /some-path von dem Pfad der Anfrage weg

Caddy ist der einzige der 3 welcher automatisch TLS Zertifikate erstellt.
In dieser Demo sind diese selber signiert also nicht von einer Cerfificate Authority ausgestellt.

=== TLS?

TLS (Transport Layer Security) ist ein Verschl√ºsselungsprotokoll, das die Sicherheit der Kommunikation im Internet gew√§hrleistet. +
link:https://tls13.xargs.org/#open-all[Wie funktioniert der genau?]

image:tls-handshake.svg[]

==== Wie bekomme ich so ein Zertifikat?

Ganz einfach. Selber machen.

[source, bash]
----
openssl genrsa -out private.key 4096 <1>
openssl req -new -key private.key -out request.csr -subj "/CN=DOMAIN_NAME" <2>
openssl x509 -req -days 365 -in request.csr -signkey private.key -out certificate.crt <3>
openssl dhparam -out dhparam.pem 4096 <4>

----
<1> Generiert einen 4096 byte langen private key
<2> Generiert eine Certifacet Signing Request (Zertifikt Unterschreibungs Anfrage) +
DOMAIN_NAME sollte mit der tats√§chlichen Domain ausgetauscht werden.
<3> Generiert das tats√§chliche Zertifikat welches f√ºr *365* Tage g√ºltig ist.
<4> Generiert eine 4096 byte lange Diffi-Hellman Parameter f√ºr den sicheren Schl√ºsselaustausch

==== Suppa. Wie benutzt ich das jetzt?

.conf.d/reverse-proxy.conf
[source, conf]
----
ssl_certificate /etc/ssl/certificate.crt;
ssl_certificate_key /etc/ssl/private.key;
ssl_dhparam /etc/nginx/dhparam.pem;
ssl_protocols TLSv1.3;

server {
    listen 443 ssl;

    server_name localhost;

    location /some-path/ {
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_pass http://nginx-echo:8080/;
    }
}

server {
    listen 443 ssl;

    server_name echo.localhost;

    location / {
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_pass http://nginx-echo:8080;
    }
}
----

So schwer war des jetzt ned. Wenn man im Browser jetzt **https**://echo.localhost aufruft wird man von dieser wundersch√∂nen Warnung begr√º√üt.

image:self-signed-warning.png[]

Was kann man dagegen tun? Nichts. Au√üer man benutzt Zertifikate die von sogenanten "Certifcate Authorities" ausgestellt werden. +
Daf√ºr braucht man eine √ñffentliche Domain, welche auf den Server zeigt, auf den der Reverse Proxy l√§uft.

Ein selbstsigniertes Zertifikat bedeutet, dass der Server selbst behauptet, seine Identit√§t und Inhalte seien vertrauensw√ºrdig. +
Es ist geeignet f√ºr Development Zwecke oder in internen Netzwerken, wenn keine CA die Validit√§t versichern kann.

image:trust-me-bro.jpg[]

=== Was ist eine Certifcate Authority

Eine Certificate Authority (Zertifikat Authorit√§t), ist ein Unternehmen oder eine Organisation, die die Validit√§t von Websiten, E-Mail-Adressen etc mithilfe von Zertifikaten sicherstellt, welche an kryptografische Schl√ºssel gebunden sind.

* DigiCert $26 p.M. link:https://www.digicert.com[ü§ë]
* Sectigo $67 p.a. link:https://www.sectigo.com/ssl-certificates-tls/compare[ü§ë]
* Let‚Äôs Encrypt link:https://letsencrypt.org/[ü¶Å]

Warum ein Zertifikat kaufen, wenn man es auch kostenlos bekommen kann?

=== Certbot

Certbot ist ein Open-Source-Tool, das von der Electronic Frontier Foundation (EFF) entwickelt wurde. Es dient dazu, kostenlose TLS-Zertifikate von Let‚Äôs Encrypt zu generieren und automatisch zu erneuernCertbot ist ein Open-Source-Tool, das von der Electronic Frontier Foundation (EFF) entwickelt wurde. Es dient dazu, kostenlose TLS-Zertifikate von Let‚Äôs Encrypt zu generieren und automatisch zu erneuern. +
F√ºr die bequemlichkeit benutzen wir Certbot mit docker compose.

[IMPORTANT]
.Voraussetzungen
====
* eine *Domain*
** optional: eine statische IP Adresse
* Port *80* und *443* offen
====

In diesem Beispiel ist *DOMAIN* ein platzhalter f√ºr die wirkliche Domain.

.docker-compose.yml
[%collapsible]
====
[source, yaml]
----
services:
  nginx:
    container_name: nginx
    image: nginx:latest
    ports:
      - 80:80
      - 443:443
    volumes:
      - ./conf.d:/etc/nginx/conf.d:ro
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./certbot/www:/var/www/certbot:ro
      - ./certbot/conf:/etc/letsencrypt:ro
    restart: unless-stopped

  certbot:
    profiles:
      - certbot <1>
    container_name: cerbot
    image: certbot/certbot
    volumes:
      - ./certbot/www:/var/www/certbot:rw
      - ./certbot/conf:/etc/letsencrypt:rw

  nginx-echo:
    image: nodstuff/gecho:latest
    restart: unless-stopped
----
<1> Ich benutze hier Profiles damit bei dem `docker compose up` command der Certbot Container nicht mit gestartet wird.
====

.ACME
[%collapsible]
====
image:acme-challenge.svg[]
====

* HTTP-01 Challenge +
Certbot erstellt eine spezielle Datei auf dem Webserver, die von Let‚Äôs Encrypt √ºberpr√ºft wird. Diese Methode ist besonders einfach einzurichten und erfordert lediglich einen funktionierenden Reverse Proxy.

* DNS-01 Challenge +
Hier wird ein spezieller DNS-Eintrag erstellt, den Let‚Äôs Encrypt validiert. Diese Methode ist ideal f√ºr Wildcard-Zertifikate (*.domain.tld) oder wenn der Server nicht √∂ffentlich erreichbar ist.

.conf.d/reverse-proxy.conf
[source, yaml]
----
server {
    listen 80;

    server_name _;

    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }
}
----

.nginx.conf
[%collapsible]
====
[source, yaml]
----
user www-data;
worker_processes auto;
pid /run/nginx.pid;

include /etc/nginx/modules-enabled/*.conf;

events {
    worker_connections 768;
    # multi_accept on;
}

http {

    ##
    # Basic Settings
    ##

    sendfile on;
    tcp_nopush on;
    types_hash_max_size 2048;

    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    ##
    # SSL Settings
    ##

    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE
    ssl_prefer_server_ciphers on;

    ##
    # Logging Settings
    ##

    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    ##
    # Gzip Settings
    ##

    gzip on;

    ##
    # Cache Settings
    ##

    proxy_cache_path /var/cache/nginx keys_zone=api-cache:10m;

    ##
    # Virtual Host Configs
    ##

    include /etc/nginx/conf.d/*.conf;
}
----
====

Mit `docker compose up -d` werden die services gestartet.

[source, bash]
----
DOMAINS=DOMAIN,SUB.DOMAIN... docker compose run --rm certbot certonly \
	--webroot --webroot-path /var/www/certbot \
	--dry-run \
	-d $DOMAINS \
	--register-unsafely-without-email --agree-tos
----

Dieser Command startet den certbot service und testet ob die Austellung eines Zertifikates m√∂glich ist.

[source, bash]
----
DOMAINS=DOMAIN,SUB.DOMAIN... docker compose run --rm certbot certonly \
	--webroot --webroot-path /var/www/certbot \
	-d $DOMAINS \
	--register-unsafely-without-email --agree-tos
----

image:certbot-get-certificate.png[]

Die Zertifikate findet man unter `/etc/letsencrypt/live/DOMAIN/` +
Erg√§nzen wir also die `reverse-proxy.conf` um https hinzuzuf√ºgen.

.conf.d/reverse-proxy.conf
[source, conf]
----
server {
    listen 80;

    server_name _;

    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }

    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl;

    server_name DOMAIN;

    ssl_certificate /etc/letsencrypt/live/DOMAIN/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/DOMAIN/privkey.pem;

    location /some-path/ {
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_pass http://nginx-echo:8080/;  # the trailing / is important...
    }
}

server {
    listen 443 ssl;

    server_name echo.DOMAIN;

    ssl_certificate /etc/letsencrypt/live/DOMAIN/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/DOMAIN/privkey.pem;

    location / {
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_pass http://nginx-echo:8080;
    }
}
----

Starten sie den nginx Container neu und bewundern sie ihr neues Zertifikat ohne Warnung.

==== Traefik TLS

[source, yaml]
----
services:
  traefik:
    container_name: traefik
    image: traefik:latest
    environment:
      - TRAEFIK_API=true
      - TRAEFIK_API_INSECURE=true
      - TRAEFIK_PROVIDERS_DOCKER=true
      - LOG_LEVEL=DEBUG
      - TRAEFIK_ENTRYPOINTS_WEB_ADDRESS=:80
      - TRAEFIK_ENTRYPOINTS_WEBSECURE_ADDRESS=:443
      - TRAEFIK_ENTRYPOINTS_WEB_HTTP_REDIRECTIONS_ENTRYPOINT_TO=websecure <1>
      - TRAEFIK_ENTRYPOINTS_WEB_HTTP_REDIRECTIONS_ENTRYPOINT_SCHEME=https
      - TRAEFIK_ENTRYPOINTS_WEB_HTTP_REDIRECTIONS_ENTRYPOINT_PERMANENT=true
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ./tls.toml:/providers/tls.toml <3>
      - ./certs/certificate.crt:/etc/ssl/certificate.crt:ro
      - ./certs/private.key:/etc/ssl/private.key:ro
    ports:
      - 80:80
      - 443:443
      - 8080:8080
    restart: unless-stopped
    labels:
      - traefik.http.routers.traefik.rule=Host(`localhost`)
      - traefik.http.services.traefik.loadbalancer.server.port=8080
      - traefik.http.routers.traefik.tls=true <2>
      - traefik.http.routers.traefik.entrypoints=websecure <1>

  traefik-echo-1:
    image: nodstuff/gecho:latest
    restart: unless-stopped
    labels:
      - traefik.http.routers.echo-1.rule=Host(`localhost`) && PathPrefix(`/some-path`)
      - traefik.http.routers.echo-1.middlewares=strip-prefix@docker
      - traefik.http.middlewares.strip-prefix.stripprefix.prefixes=/some-path
      - traefik.http.services.echo-1.loadbalancer.server.port=8080
      - traefik.http.routers.echo-1.tls=true <2>
      - traefik.http.routers.echo-1.entrypoints=websecure <1>

  traefik-echo-2:
    image: nodstuff/gecho:latest
    restart: unless-stopped
    ports:
      - 8000:8080
    labels:
      - traefik.http.routers.echo-2.rule=Host(`echo.localhost`)
      - traefik.http.routers.echo-2.tls=true <2>
      - traefik.http.routers.echo-2.entrypoints=websecure <1>
      # - traefik.http.services.echo.loadbalancer.server.port=8080
      # not needed because of traefik automatic service discovery magic
----
<1>

==== Nginx Ingress Controller

===== Minikube

[source, bash]
----
minikube start --addons=dashboard,metrics-server
----

.ingress-controller.yml
[%collapsible]
====
* https://kubernetes.github.io/ingress-nginx/developer-guide/getting-started/

[source, yaml]
----
apiVersion: v1
kind: Namespace
metadata:
  labels:
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
  name: ingress-nginx
---
apiVersion: v1
automountServiceAccountToken: true
kind: ServiceAccount
metadata:
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.12.0-beta.0
  name: ingress-nginx
  namespace: ingress-nginx
---
apiVersion: v1
automountServiceAccountToken: true
kind: ServiceAccount
metadata:
  labels:
    app.kubernetes.io/component: admission-webhook
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.12.0-beta.0
  name: ingress-nginx-admission
  namespace: ingress-nginx
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.12.0-beta.0
  name: ingress-nginx
  namespace: ingress-nginx
rules:
  - apiGroups:
      - ""
    resources:
      - namespaces
    verbs:
      - get
  - apiGroups:
      - ""
    resources:
      - configmaps
      - pods
      - secrets
      - endpoints
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - ""
    resources:
      - services
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - networking.k8s.io
    resources:
      - ingresses
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - networking.k8s.io
    resources:
      - ingresses/status
    verbs:
      - update
  - apiGroups:
      - networking.k8s.io
    resources:
      - ingressclasses
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - coordination.k8s.io
    resourceNames:
      - ingress-nginx-leader
    resources:
      - leases
    verbs:
      - get
      - update
  - apiGroups:
      - coordination.k8s.io
    resources:
      - leases
    verbs:
      - create
  - apiGroups:
      - ""
    resources:
      - events
    verbs:
      - create
      - patch
  - apiGroups:
      - discovery.k8s.io
    resources:
      - endpointslices
    verbs:
      - list
      - watch
      - get
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  labels:
    app.kubernetes.io/component: admission-webhook
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.12.0-beta.0
  name: ingress-nginx-admission
  namespace: ingress-nginx
rules:
  - apiGroups:
      - ""
    resources:
      - secrets
    verbs:
      - get
      - create
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  labels:
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.12.0-beta.0
  name: ingress-nginx
rules:
  - apiGroups:
      - ""
    resources:
      - configmaps
      - endpoints
      - nodes
      - pods
      - secrets
      - namespaces
    verbs:
      - list
      - watch
  - apiGroups:
      - coordination.k8s.io
    resources:
      - leases
    verbs:
      - list
      - watch
  - apiGroups:
      - ""
    resources:
      - nodes
    verbs:
      - get
  - apiGroups:
      - ""
    resources:
      - services
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - networking.k8s.io
    resources:
      - ingresses
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - ""
    resources:
      - events
    verbs:
      - create
      - patch
  - apiGroups:
      - networking.k8s.io
    resources:
      - ingresses/status
    verbs:
      - update
  - apiGroups:
      - networking.k8s.io
    resources:
      - ingressclasses
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - discovery.k8s.io
    resources:
      - endpointslices
    verbs:
      - list
      - watch
      - get
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  labels:
    app.kubernetes.io/component: admission-webhook
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.12.0-beta.0
  name: ingress-nginx-admission
rules:
  - apiGroups:
      - admissionregistration.k8s.io
    resources:
      - validatingwebhookconfigurations
    verbs:
      - get
      - update
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.12.0-beta.0
  name: ingress-nginx
  namespace: ingress-nginx
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: ingress-nginx
subjects:
  - kind: ServiceAccount
    name: ingress-nginx
    namespace: ingress-nginx
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  labels:
    app.kubernetes.io/component: admission-webhook
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.12.0-beta.0
  name: ingress-nginx-admission
  namespace: ingress-nginx
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: ingress-nginx-admission
subjects:
  - kind: ServiceAccount
    name: ingress-nginx-admission
    namespace: ingress-nginx
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  labels:
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.12.0-beta.0
  name: ingress-nginx
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: ingress-nginx
subjects:
  - kind: ServiceAccount
    name: ingress-nginx
    namespace: ingress-nginx
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  labels:
    app.kubernetes.io/component: admission-webhook
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.12.0-beta.0
  name: ingress-nginx-admission
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: ingress-nginx-admission
subjects:
  - kind: ServiceAccount
    name: ingress-nginx-admission
    namespace: ingress-nginx
---
apiVersion: v1
data: null
kind: ConfigMap
metadata:
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.12.0-beta.0
  name: ingress-nginx-controller
  namespace: ingress-nginx
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.12.0-beta.0
  name: ingress-nginx-controller
  namespace: ingress-nginx
spec:
  externalTrafficPolicy: Local
  ipFamilies:
    - IPv4
  ipFamilyPolicy: SingleStack
  ports:
    - appProtocol: http
      name: http
      port: 80
      protocol: TCP
      targetPort: http
    - appProtocol: https
      name: https
      port: 443
      protocol: TCP
      targetPort: https
  selector:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
  type: LoadBalancer
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.12.0-beta.0
  name: ingress-nginx-controller-admission
  namespace: ingress-nginx
spec:
  ports:
    - appProtocol: https
      name: https-webhook
      port: 443
      targetPort: webhook
  selector:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.12.0-beta.0
  name: ingress-nginx-controller
  namespace: ingress-nginx
spec:
  minReadySeconds: 0
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      app.kubernetes.io/component: controller
      app.kubernetes.io/instance: ingress-nginx
      app.kubernetes.io/name: ingress-nginx
  strategy:
    rollingUpdate:
      maxUnavailable: 1
    type: RollingUpdate
  template:
    metadata:
      labels:
        app.kubernetes.io/component: controller
        app.kubernetes.io/instance: ingress-nginx
        app.kubernetes.io/name: ingress-nginx
        app.kubernetes.io/part-of: ingress-nginx
        app.kubernetes.io/version: 1.12.0-beta.0
    spec:
      containers:
        - args:
            - /nginx-ingress-controller
            - --publish-service=$(POD_NAMESPACE)/ingress-nginx-controller
            - --election-id=ingress-nginx-leader
            - --controller-class=k8s.io/ingress-nginx
            - --ingress-class=nginx
            - --configmap=$(POD_NAMESPACE)/ingress-nginx-controller
            - --validating-webhook=:8443
            - --validating-webhook-certificate=/usr/local/certificates/cert
            - --validating-webhook-key=/usr/local/certificates/key
          env:
            - name: POD_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
            - name: LD_PRELOAD
              value: /usr/local/lib/libmimalloc.so
          image: registry.k8s.io/ingress-nginx/controller:v1.12.0-beta.0@sha256:9724476b928967173d501040631b23ba07f47073999e80e34b120e8db5f234d5
          imagePullPolicy: IfNotPresent
          lifecycle:
            preStop:
              exec:
                command:
                  - /wait-shutdown
          livenessProbe:
            failureThreshold: 5
            httpGet:
              path: /healthz
              port: 10254
              scheme: HTTP
            initialDelaySeconds: 10
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 1
          name: controller
          ports:
            - containerPort: 80
              name: http
              protocol: TCP
            - containerPort: 443
              name: https
              protocol: TCP
            - containerPort: 8443
              name: webhook
              protocol: TCP
          readinessProbe:
            failureThreshold: 3
            httpGet:
              path: /healthz
              port: 10254
              scheme: HTTP
            initialDelaySeconds: 10
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 1
          resources:
            requests:
              cpu: 100m
              memory: 90Mi
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              add:
                - NET_BIND_SERVICE
              drop:
                - ALL
            readOnlyRootFilesystem: false
            runAsGroup: 82
            runAsNonRoot: true
            runAsUser: 101
            seccompProfile:
              type: RuntimeDefault
          volumeMounts:
            - mountPath: /usr/local/certificates/
              name: webhook-cert
              readOnly: true
      dnsPolicy: ClusterFirst
      nodeSelector:
        kubernetes.io/os: linux
      serviceAccountName: ingress-nginx
      terminationGracePeriodSeconds: 300
      volumes:
        - name: webhook-cert
          secret:
            secretName: ingress-nginx-admission
---
apiVersion: batch/v1
kind: Job
metadata:
  labels:
    app.kubernetes.io/component: admission-webhook
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.12.0-beta.0
  name: ingress-nginx-admission-create
  namespace: ingress-nginx
spec:
  template:
    metadata:
      labels:
        app.kubernetes.io/component: admission-webhook
        app.kubernetes.io/instance: ingress-nginx
        app.kubernetes.io/name: ingress-nginx
        app.kubernetes.io/part-of: ingress-nginx
        app.kubernetes.io/version: 1.12.0-beta.0
      name: ingress-nginx-admission-create
    spec:
      containers:
        - args:
            - create
            - --host=ingress-nginx-controller-admission,ingress-nginx-controller-admission.$(POD_NAMESPACE).svc
            - --namespace=$(POD_NAMESPACE)
            - --secret-name=ingress-nginx-admission
          env:
            - name: POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
          image: registry.k8s.io/ingress-nginx/kube-webhook-certgen:v1.4.4@sha256:a9f03b34a3cbfbb26d103a14046ab2c5130a80c3d69d526ff8063d2b37b9fd3f
          imagePullPolicy: IfNotPresent
          name: create
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
                - ALL
            readOnlyRootFilesystem: true
            runAsGroup: 65532
            runAsNonRoot: true
            runAsUser: 65532
            seccompProfile:
              type: RuntimeDefault
      nodeSelector:
        kubernetes.io/os: linux
      restartPolicy: OnFailure
      serviceAccountName: ingress-nginx-admission
---
apiVersion: batch/v1
kind: Job
metadata:
  labels:
    app.kubernetes.io/component: admission-webhook
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.12.0-beta.0
  name: ingress-nginx-admission-patch
  namespace: ingress-nginx
spec:
  template:
    metadata:
      labels:
        app.kubernetes.io/component: admission-webhook
        app.kubernetes.io/instance: ingress-nginx
        app.kubernetes.io/name: ingress-nginx
        app.kubernetes.io/part-of: ingress-nginx
        app.kubernetes.io/version: 1.12.0-beta.0
      name: ingress-nginx-admission-patch
    spec:
      containers:
        - args:
            - patch
            - --webhook-name=ingress-nginx-admission
            - --namespace=$(POD_NAMESPACE)
            - --patch-mutating=false
            - --secret-name=ingress-nginx-admission
            - --patch-failure-policy=Fail
          env:
            - name: POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
          image: registry.k8s.io/ingress-nginx/kube-webhook-certgen:v1.4.4@sha256:a9f03b34a3cbfbb26d103a14046ab2c5130a80c3d69d526ff8063d2b37b9fd3f
          imagePullPolicy: IfNotPresent
          name: patch
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
                - ALL
            readOnlyRootFilesystem: true
            runAsGroup: 65532
            runAsNonRoot: true
            runAsUser: 65532
            seccompProfile:
              type: RuntimeDefault
      nodeSelector:
        kubernetes.io/os: linux
      restartPolicy: OnFailure
      serviceAccountName: ingress-nginx-admission
---
apiVersion: networking.k8s.io/v1
kind: IngressClass
metadata:
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.12.0-beta.0
  name: nginx
spec:
  controller: k8s.io/ingress-nginx
---
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  labels:
    app.kubernetes.io/component: admission-webhook
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.12.0-beta.0
  name: ingress-nginx-admission
webhooks:
  - admissionReviewVersions:
      - v1
    clientConfig:
      service:
        name: ingress-nginx-controller-admission
        namespace: ingress-nginx
        path: /networking/v1/ingresses
        port: 443
    failurePolicy: Fail
    matchPolicy: Equivalent
    name: validate.nginx.ingress.kubernetes.io
    rules:
      - apiGroups:
          - networking.k8s.io
        apiVersions:
          - v1
        operations:
          - CREATE
          - UPDATE
        resources:
          - ingresses
    sideEffects: None
----

[source, bash]
---
kubectl apply -f ingress-controller.yml
---
====

oder

[source, bash]
----
minikube addons enable ingress
----

.echo.yml
[%collapsible]
====
[source, bash]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: echo
  labels:
    name: echo
spec:
  replicas: 1
  selector:
    matchLabels:
      name: echo
  template:
    metadata:
      name: echo
      labels:
        name: echo
    spec:
      containers:
        - name: echo
          image: nodstuff/gecho:latest
          ports:
            - containerPort: 8080
---
apiVersion: v1
kind: Service
metadata:
  name: echo-service
spec:
  selector:
    name: echo
  ports:
    - name: http
      protocol: TCP
      port: 8080
      targetPort: 8080
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: echo-ingress
spec:
  ingressClassName: nginx
  rules:
    - http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: echo-service
                port:
                  number: 8080
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: echo-ingress-rewrite
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/rewrite-target: /$2 <2>
spec:
  ingressClassName: nginx
  rules:
    - http:
        paths:
          - path: /some-path(/|$)(.*) <1>
            pathType: ImplementationSpecific
            backend:
              service:
                name: echo-service
                port:
                  number: 8080
----
<1> Mit diesem Regex werden 2 Capture Groups gematched. +
z.B. /some-path(/)(i-love-turtles)
<2> Mit dieser Annotation wird der Pfad √ºberschrieben mit der zweiter Capture Group +
z.B. /some-path(/)(i-love-turtles) => /i-love-turtles
====

[source, bash]
----
kubectl apply -f echo.yml
----

Die externe Ip erh√§lt man mit diesem Command.

[source, bash]
----
kubectl get svc -n ingress-nginx
----

Der Ingress Controller sollte unter der Ip erreichbar sein.

Falls nicht muss man in das minikube Netzwerk hineintunneln mit

[source, bash]
----
minikube tunnel
----

===== Leocloud

Da die Leocloud schon einen Ingress-Controller zur verf√ºgung stellt ist es nicht n√∂tig einen weitern zu deployen.

[IMPORTANT]
====
Es wird angenommen, dass kubectl konfiguriert ist mit der leocloud zu arbeiten. +
link:https://cloud.htl-leonding.ac.at/html/user-manual.html[Setup]
====

.echo.yml
[%collapsible]
====
[source, bash]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: echo
  labels:
    name: echo
spec:
  replicas: 1
  selector:
    matchLabels:
      name: echo
  template:
    metadata:
      name: echo
      labels:
        name: echo
    spec:
      containers:
        - name: echo
          image: nodstuff/gecho:latest
          ports:
            - containerPort: 8080
---
apiVersion: v1
kind: Service
metadata:
  name: echo-service
spec:
  selector:
    name: echo
  ports:
    - name: http
      protocol: TCP
      port: 8080
      targetPort: 8080
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: echo-ingress
spec:
  ingressClassName: nginx
  rules:
    - host: STUDENT_ID.cloud.htl-leonding.ac.at <1>
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: echo-service
                port:
                  number: 8080
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: echo-ingress-rewrite
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/rewrite-target: /$2
spec:
  ingressClassName: nginx
  rules:
    - host: STUDENT_ID.cloud.htl-leonding.ac.at <1>
      http:
        paths:
          - path: /some-path(/|$)(.*)
            pathType: ImplementationSpecific
            backend:
              service:
                name: echo-service
                port:
                  number: 8080

----
<1> Alle Anfragen auf STUDENT_ID.cloud.htl-leonding.ac.at werden zu dem echo-pod service weitergeleitet +
Die STUDENT_ID muss mit deiner eigenen ausgetauscht werden. +
Weiters ist es nicht m√∂glich (Stand 19.12.2024) Subdomains zu ben√ºtzen. +
z.B. echo.STUDENT_ID.cloud.htl-leonding.ac.at

image:leocloud-subdomain-error.png[]
====

==== Traefik Ingress Controller

===== Minikube

[source, bash]
----
minikube start --addons=dashboard,metrics-server
----

.ingress-controller.yml
[%collapsible]
====
* https://doc.traefik.io/traefik/getting-started/quick-start-with-kubernetes/

[source, yaml]
----
apiVersion: v1
kind: Namespace
metadata:
  name: traefik

---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: traefik-role
  namespace: traefik

rules:
  - apiGroups:
      - ""
    resources:
      - services
      - secrets
      - nodes
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - discovery.k8s.io
    resources:
      - endpointslices
    verbs:
      - list
      - watch
  - apiGroups:
      - extensions
      - networking.k8s.io
    resources:
      - ingresses
      - ingressclasses
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - extensions
      - networking.k8s.io
    resources:
      - ingresses/status
    verbs:
      - update
  - apiGroups:
      - traefik.io
    resources:
      - middlewares
      - middlewaretcps
      - ingressroutes
      - traefikservices
      - ingressroutetcps
      - ingressrouteudps
      - tlsoptions
      - tlsstores
      - serverstransports
      - serverstransporttcps
    verbs:
      - get
      - list
      - watch
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: traefik-account
  namespace: traefik
---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: traefik-role-binding

roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: traefik-role
subjects:
  - kind: ServiceAccount
    name: traefik-account
    namespace: traefik
---
kind: Deployment
apiVersion: apps/v1
metadata:
  name: traefik-deployment
  namespace: traefik
  labels:
    app: traefik

spec:
  replicas: 1
  selector:
    matchLabels:
      app: traefik
  template:
    metadata:
      labels:
        app: traefik
    spec:
      serviceAccountName: traefik-account
      containers:
        - name: traefik
          image: traefik:v3.2
          args:
            - --api.insecure
            - --providers.kubernetesingress
          ports:
            - name: web
              containerPort: 80
            - name: dashboard
              containerPort: 8080
---
apiVersion: v1
kind: Service
metadata:
  name: traefik-dashboard-service
  namespace: traefik

spec:
  type: LoadBalancer
  ports:
    - port: 8080
      targetPort: dashboard
  selector:
    app: traefik
---
apiVersion: v1
kind: Service
metadata:
  name: traefik-web-service
  namespace: traefik

spec:
  type: LoadBalancer
  ports:
    - targetPort: web
      port: 80
  selector:
    app: traefik
----
====

[source, bash]
----
kubectl apply -f ingress-controller.yml
----

.echo.yml
[%collapsible]
====
[source, bash]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: echo
  labels:
    name: echo
spec:
  replicas: 1
  selector:
    matchLabels:
      name: echo
  template:
    metadata:
      name: echo
      labels:
        name: echo
    spec:
      containers:
        - name: echo
          image: nodstuff/gecho:latest
          ports:
            - containerPort: 8080
---
apiVersion: v1
kind: Service
metadata:
  name: echo-service
spec:
  selector:
    name: echo
  ports:
    - name: http
      protocol: TCP
      port: 8080
      targetPort: 8080

---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: echo-ingress
spec:
  ingressClassName: traefik
  rules:
    - http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: echo-service
                port:
                  number: 8080
----
====

[source, bash]
----
kubectl apply -f echo.yml
----

Die externe Ip erh√§lt man mit diesem Command.

[source, bash]
----
kubectl get svc -n ingress-nginx
----

Der Ingress Controller sollte unter der Ip erreichbar sein.

Falls nicht muss man in das minikube Netzwerk hineintunneln mit

[source, bash]
----
minikube tunnel
----

== Quellen
* Keycloak - Identity and Access Management for Modern Applications (Second Edition)
* https://quarkus.io/guides/security-keycloak-admin-client
* https://www.okta.com/de/identity-101/whats-the-difference-between-oauth-openid-connect-and-saml/
* https://www.microsoft.com/de-de/security/business/security-101/what-is-oauth
* https://auth0.com/de/intro-to-iam/what-is-oauth-2
* https://auth0.com/de/intro-to-iam/what-is-openid-connect-oidc
* https://auth0.com/de/intro-to-iam/what-is-saml
* https://www.keycloak.org/
* https://goauthentik.io/
* https://jwt.io/
* https://medium.com/@nishada/securing-a-javascript-app-using-keycloak-263fdbbc9d02
* https://datatracker.ietf.org/doc/html/rfc7519#section-4.1
* https://traefik.io/glossary/reverse-proxy/ (a bissl marketing halluzinationen oba is ned so schlecht)
* https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/
* https://stytch.com/blog/jwt-claims/
* https://www.keycloak.org/docs/latest/server_development
* https://www.ssldragon.com/de/blog/wie-werde-zertifizierungs-autoritaet/
* https://www.researchgate.net/figure/TLS-handshake-protocol_fig1_298065605
* https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake/
